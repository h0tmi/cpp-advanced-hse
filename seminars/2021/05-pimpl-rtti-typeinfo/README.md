# Семинар 5. Идиома pImpl; vtable, RTTI и их использование

## План

### pImpl

1.1. Напоминание про компиляцию и сборку C++ кода (на лекции было, но стоит напомнить)

* три этапа: препроцессинг, компиляция каждой единицы трансляции, линковка
* библиотеки либо целиком header-only, либо предоставляются открытые header-ы и бинарник для статической (`.a`) или
  динамической (`.so`) линковки
* как мы привыкли делать: декларация класса, описание всех полей и декларация методов в `.h`, реализация - в `.cpp`

1.2. Какие проблемы создает описание класса в header-файле

* перекомпиляция при любом изменении header-ов и отсутствие обратной совместимости ABI (поменяли что-либо, влияющее на layout в классе - сломали совместимость)
* открытость приватных членов (может хотеться закрыть либо по коммерческим причинам, либо чтобы символы не проникали в
  IDE пользователю)
* большие header-ы транзитивно попадают в каждую единицу трансляции кода пользователя. Увеличивается размер бинарного
  файла и время компиляции

1.3. Реализация pImpl

Будем поэтапно писать pImpl для такого кейса: есть наш интерфейс для `StringSplitter`-а (удобный пользователям), который
под капотом использует boost (см. [pimpl/third-party](pimpl/third-party)) со всеми вытекающими последствиями. Избавимся
от boost-ового хэдера в пользовательских файлах.

Сборка всех подпроектов через [CMake](pimpl/CMakeLists.txt), понадобятся хэдеры boost-а.

| №  | Где лежит код                        | Что происходит                                                                                      |
 | ---|--------------------------------------|-----------------------------------------------------------------------------------------------------|
| 0  | [pimpl/no-pimpl](pimpl/no-pimpl)     | вариант без pimpl, инклюд библиотеки в хедере                                                      |
| 1  | [pimpl/raw-ptr](pimpl/raw-ptr)       | pimpl на сыром указателе                                                                            |
| 2  | [pimpl/unique-ptr](pimpl/unique-ptr) | pimpl на `std::unique_ptr`, в комментариях еще см. про `std::shared_ptr`                            |
| 3  | [pimpl/fast](pimpl/fast)             | fast pimpl (не аллоцируем в куче), валидация `sizeof` и `alignof` в compile-time (см. деструктор)   |

### vtable

2.1. Механизм виртуальных функций

* рассказать, что такое таблица виртуальных функций (хранит указатели на самый дочерний из доступных вариант метода,
  см. [vtable.png](vtable.png))
* реализация полиморфизма не специфирована в стандарте, но все делают через этот механизм

2.2. Показываем пример кода: https://godbolt.org/z/95WfsEz51. Keypoints:

* на `-O0` видны реализации дефолтных конструкторов. Обратить внимание на то, что указатель на vtable кладется в начало
  класса

* показать, что код самих виртуальных функций `NameYourself()` не отличается от кода невиртуальной
  функции `NonVirtualMethod()`. Отличие в точке вызова `CallNameYourself()` - оно выполняется в три ассемблерные
  инструкции: прочтение указателя на vtable, прочтение адреса метода в таблице и собственно вызов метода

* показать, как располагаются друг относительно друга виртуальные методы базового класса и наследника (`IAmVirtualAsWell`)

* переключиться на `-O2` и показать, что произошла девиртуализация - в данном случае возможно определить точные типы
  всех переменных во время компиляции и необходимость в рантайм диспетчеризации отпадает. Правда, тут еще и функции
  заинлайнены.
  
2.3. `dynamic_cast` ссылок и указателей. Примеры кода в [rtti](rtti).

* сначала показать базовый пример работы с dynamic_cast [тут](rtti/event_dispatcher_1_dynamic_cast.cpp)

* объяснить, почему конкретно эту задачу лучше решать через виртуальные функции (переписанный код [здесь](rtti/event_dispatcher_2_virtual.cpp)).

* рассказать, что в общем случае такой функциональности может не хватать:

  - может не быть возможности произвольно менять код `Event`-ов, может не хотеться описывать в них сценарии обработки (а использовать просто как структуры для хранения контекста)

  - эту задачу решает паттерн Visitor (переписанный код [здесь](rtti/event_dispatcher_3_visitor_pattern.cpp)). В этом паттерне можно научить `Event` отправлять указатель на себя в переданный ему "visitor", который получит доступ к контексту события и сможет его обрабатывать произвольным образом
  
  - обратить внимание, что в visitor происходит "двойная диспетчеризация" - механизм виртуальных функций срабатывает сначала в вызове `event->AcceptHandler()` (`IEvent`->реальный тип события), затем в `handler->Handle...()` (`IEventHandler`->`EventLogger`)
  
  - в visitor еще много forward declaration-ов, хороший повод про них еще раз напомнить, в чате были вопросы
  
* стоит проговорить вслух, почему нет `dynamic_cast` по значению

* не всегда требует RTTI, upcasts выполняются в compile-time ([здесь](rtti/dynamic_cast_no_polymorphism.cpp))

* вернуться к примеру на godbolt из прошлого пункта и показать, что в vtable помимо указателей на методы есть
  еще `typeinfo`
  
* обзорно про механику работы `dynamic_cast`:
  
  - простой каст (за константное время) к most-derived: `dynamic_cast<void*>`: смотрим в виртуальную таблицу, на которую указывает vptr. Там (возможно по offset) можно узнать most derived type
    
  - sidecast и cast к произвольному дочернему в иерархии дорогие, делаются обходом некоего inheritance graph

* `any` без RTTI ([any-no-rtti.cpp](rtti/any-no-rtti.cpp))

  - на самом деле, в `any` всегда делается каст к most-derived объекту
  
  - напомнить про инстанцирование шаблонов: для каждого шаблонного параметра будет своя копия функции в коде
  
  - делаем сравнение указателей на функцию `ptr_->GetTag() == &NoOp<T>` - она будет в единственном экземпляре в бинарнике и это валидно

2.4. `typeid`, `std::type_info`. Примеры кода в [rtti](rtti).

* тоже не всегда требует RTTI. Для неполиморфных типов [эквивалентен](rtti/typeid_no_polymorphism.cpp) `typeid(decltype(expression))`.

* возвращает `const std::type_info&`.

2.5. pImpl vs абстрактный базовый класс

* indirection в обоих случаях

* pImpl неприменим, когда нужны шаблоны

* ABI break

### Обсуждение задач

3.1. `pimpl` - обсудили выше, сама задача простая

3.2. `any` - написали на лекции

3.3. `editor` - ничего сложного, разберутся

3.4. `small-test-framework` - ничего сложного, разберутся

3.5. `scala-vector` - и здесь тоже

### Основные источники

1) https://youtu.be/mkPTreWiglk?t=150 - хорошо про pImpl, fast pImpl
2) https://blog.panicsoftware.com/dynamic_cast-and-typeid-as-non-rtti-tools/ - почти весь код в rtti оттуда
3) https://www.youtube.com/watch?v=QzJL-8WbpuU - dynamic_cast
4) https://shaharmike.com/cpp/vtable-part1/ - подробно про vtable, в том числе при множественном наследовании