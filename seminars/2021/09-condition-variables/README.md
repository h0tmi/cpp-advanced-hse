# Condition variables

Сегодня говорим про condition variables;
теперь можем написать много полезных многопоточных примитивов.
Condition variables, как следует из названия, позволяют дожидаться выполнения некоторого условия, не сжигая
ресурс CPU понапрасну.

### Event
Начнем с простого: пишем примитивный класс Event, который можно подождать: [01-event.cpp](01-event.cpp).
```cpp
class Event {
public:
    void Notify();
    void Wait();
};
```

+ Почему недостаточно `wait` без предиката? condvar случайно пробуждается.
+ Как работает предикат в `wait`? `wait` при входе в него отпускает мьютекс и засыпает, позволяя
другим потокам так же ждать на этом мьютексе. Проверка предиката при этом происходит под блокировкой, как и остальной код пользователя. В этом смысле wait не отличается от
```cpp
while (!pred()) {
    cv.wait(lock);
}
```
+ Зачем condition_variable mutex? Он на самом деле защищает внутренний стейт condition_variable;
использовать без mutex явно или неявно (`std::condition_variable_any`) не получится.
+ Почему `notify_all` делаем не под локом? Чтоб разбуженный поток не ушел обратно спать на попытке залочить
мьютекс. На Linux pthreads умеют эту ситуацию оптимизировать, но все равно оверхед будет.
+ Что конкретно происходит при ожидании на cv? Поток отправляется спать в систему и не тратит CPU. При этом
используется специальный системный вызов, так что ядро знает, что поток спит, и может оперировать очередями из потоков, спящих на определенных cv.
+ Зачем `notify_one`, когда есть `notify_all`? Будить все потоки нужно не всегда, и это довольно дорогая
операция: каждый поток проснется, возьмет блокировку и проверит условие.
+ Что будет при notify, если никто не спит? **Уведомление пропустится**. В частности поэтому недостаточно
`wait()` без предиката: нужно уметь отличать такие ситуации.
+ Почему `std::lock_guard` не работает с `std::condition_variable`? `std::condition_variable` должна уметь
разблокировать мьютекс.

### Latch
Простой барьер; внутри один счетчик. Сначала счетчик равен максимальному значению; каждый вызов `Arrive`
уменьшает счетчик; `Wait` ждет, пока счетчик станет 0.
```cpp
class Latch {
public:
    void Arrive();
    void Wait();
};
```

Зачем нужно: синхронизация потоков. Ждем, пока все потоки пройдут некоторую логическую точку.
Опять будем искать сумму корней чисел до миллиарда.
С Latch можно показывать сумму прогрессивно: [02-latch.cpp](02-latch.cpp)

У Latch есть один недостаток: он блокируется при `Arrive()`.
Можно ли сделать без блокировок?
Казалось бы, давайте сделаем счетчик атомарным. Что не так в реализации [02-latch-atomic.cpp](02-latch-atomic.cpp)?

### Semaphore
Один из старейших примитивов синхронизации. Можно использовать для замены предыдущих двух: [03-semaphore.cpp](03-semaphore.cpp). Запустим 1000 потоков, но ограничим число выполняющихся в моменте. Например, похожее делает `make` при выполнении независимых задач.

### Blocking queue
Посмотрим на очередь с прошлого семинара; теперь мы ее можем написать: [04-queue.cpp](04-queue.cpp). Из примечательного --- cv стоит называть по имени предиката, который они обозначают (в примере `not_empty`).

### Thread pool
Вы могли заметить, что почти всегда мы заводим вектор `std::thread`; нет ли за этим какой-то логики?
Есть, на самом деле, потоки руками запускают редко.
Основной примитив для запуска потоков при реальной разработке --- thread pool.
Напишем самую наивную реализацию, которая уже неплохо работает: [05-thread-pool.cpp](05-thread-pool.cpp).
Мы используем очередь из прошлого примера, поэтому получается весьма компактно.

### Выводы
С `condition_variable` можно строить большое количество удобных примитивов.
В реальной разработке не так часто используют `condition_variable` напрямую,
потому как семаника все-таки не самая очевидная, но более удобные примитивы работают поверх.
