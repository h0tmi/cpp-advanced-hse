# Сборка, зависимости, экосистема

## Системы сборки

Написать код -- полдела (или даже меньше). 
Дальше нужно фиксить баги, читать чужой код, ещё фиксить баги, добавлять фичи,
убирать фичи, конфигурировать фичи, и ещё кучу всего!

>Отлично, с кодом закончили! 
Теперь можно проверить, всё ли у нас хорошо.
Нужно лишь всё собрать и запустить.
Oh, wait...

К сожалению, хранить весь код в одном файле очень тяжело для восприятия,
конфликтно для системы версионирования и плохо для времени компиляции.
Поэтому разработчики стараются разбивать код на файлы, что ведёт к другой
сложности -- как собрать эту кучу файлов вместе и скомпилировать?

Можно, конечно, сделать один большой bash скрипт, в котором будут перечислены
все файлы и одна большая команда для таргетного компилятора:

```shell
clang++ \
  -std=c++42 \
  -Wall -Werror -Wextra -Wpedantic -Whowmanyflagsdoihavetoputhere \
  -o main \
  search.cpp logger.cpp allocator.cpp main.cpp
```

Однако такой подход вынуждает компилировать все файлы заново на каждый чих.
Чтобы такого избежать, нужно кэшировать результаты компиляции 
(_артефакты_) отдельных TU (translation units) и компилировать их заново только 
в случае, если изменились исходники.

Более того, собирать проект хочется с разными опциями:

* В продакшен мы катим (чаще всего) релизную сборку.
* Тестим в дебажной и в релизной с санитайзерами.
* Иногда нужна релизная сборка с дебажными символами.

Обрабатывать все эти вариации в нашем несчастном bash скрипте -- дело тяжёлое
и неблагодарное.

Помимо всего этого, в крупных компаниях существует распределённая сборка --
одновременная компиляция разных TU на разных машинах, чтобы ускорить процесс
сборки для огромных проектов.

Видно, что проблема довольно насущная и её решение напрямую влияет на
разработчиков (например, сколько времени они тратят впустую, пока ждут
компиляцию очередного шаблона) и качество продакшена.

Решением тут выступают системы сборки -- специализированный софт, который
собирает другой софт. 
В нашем курсе, например, используется CMake (про него мы ещё чуть позже
поговорим).

### Make

Вещи, придуманные в 80-90-х годах, до сих пор работают и иногда делают
это достаточно эффективно: точно также обстоят дела с системой Make.

Для того чтобы начать сборку, Make ищет файл Makefile, в котором описаны
основные таргеты и их зависимости. 
Сами Makefile-ы напоминают последовательность команд (почти как bash скрипты),
однако Make умеет понимать, когда артефакты are up-to-date и не требуют 
повторной сборки.

Для маленьких и небольших проектов Make вполне может хватить,
но стоит понимать, что использование Make перекладывает на вас ответственность
за кросс-платформенность сборки (потому что последовательность shell команд
зависит от используемого shell'а -- POSIX команды bash'а могут не работать
на Windows).

[Примеры сборки доступны тут](./build-systems/make).

### Ninja

Make -- это, конечно, хорошо, но можно ли побыстрее?
Можно:

![ninja-vs-make](https://www.incredibuild.com/wp-content/uploads/2021/04/Ninja_top-open-source-build-tools.jpg)

Ninja точно так же позволяет собирать проекты (небольшие можно вручную,
большие вручную не выйдет: подробнее дальше), причём эта система 
сборки делает основной упор на скорость.

Синтаксис Ninja не позволяет делать большинство вещей, доступных в Make.
Например:

* Условия.
* Указание путей, по которым следует искать файлы для `#include`.
* Implicit rules для C/C++ (в разрез с Make, Ninja не "предпочитает" языки 
  C/C++ остальным).

"Но это же неудобно!", -- может заметить читатель.
Да, действительно, это неудобно для _людей_.
Ещё одна особенность Ninja -- адаптивность под более высокоуровневые системы
сборки; то есть Ninja выступает своего рода ассемблером для других
систем сборки. 
Иными словами, файлы с описанием сборки для Ninja должны быть сгенерированы
программно, а не написаны руками разработчиков.

По умолчанию, Ninja ищет файл `build.ninja` и собирает все устаревшие таргеты.

[Примеры сборки доступны тут](./build-systems/ninja).

### CMake

CMake -- де-факто стандартная система сборки C++
(исключение -- крупные компании, у которых есть ресурсы на разработку
и поддержку самописных систем сборки).

Строго говоря, CMake является системой мета-сборки -- сам CMake
не производит артефактов, он генерирует инструкции для более низкоуровневых
систем сборки (Make, Ninja).

Глобально в CMake можно создать две сущности:

* Библиотеку при помощи `add_library(library_name ...)`
* Исполняемый файл при помощи `add_executable(executable_name ...)`.

Поверх этого уже можно писать сложную логику с флагами компиляции,
режимами сборки (Debug, Release, etc.), линковку с разными библиотеками, 
и так далее.

CMake можно (в какой-то степени) считать языком программирования,
потому что в нём доступны переменные, функции со скоупом, подключение
модулей, поэтому старайтесь относиться к CMake как коду.

За годы своего существования CMake претерпел значительные изменения в плане 
того, как им правильно пользоваться.
До версии 3.5 большинство опций сборки распространялись как чума по 
всему проекту и его зависимостям.
Сейчас же CMake ведёт себя более гигиенично, ведя понятие `target` --
библиотека или исполняемый файл, созданные при помощи 
`add_(library|executable)`.
Дальше можно модифицировать таргет как необходимо, используя функции
с префиксом `target_`:

* Слинковать с другой библиотекой: `target_link_libraries(my_executable ...)`
* Указать флаги компиляции: `target_compile_options(my_library ...)`
* Прописать пути до include директорий: `target_include_directories(my_library ...)`

[Примеры сборки доступны тут](./build-systems/cmake).

### Meson

Meson -- альтернатива CMake со статической типизацией, но без возможности
писать собственные функции (не Тьюринг полный язык). 
Синтаксис очень похож на Python, имплементирован тоже на нём.
В качестве основной низкоуровневой системы сборки использует Ninja.

Очень подробная документация в связке со строгой типизацией избавляет
от бесконечных дебагов тривиальных вещей (переменная с пробелами раскрылась 
в список вместо непрерывной строки).

Позволяет [миксовать сборку с CMake](https://mesonbuild.com/CMake-module.html),
хотя сходу не очень понятно, насколько это безопасно и error-prone.
Имеет небольшой [репозиторий с зависимостями](https://mesonbuild.com/Wrapdb-projects.html), 
которые можно подтянуть одной командой.

На беглый взгляд довольно удобный (особенно по сравнению с CMake) 
и шустрый инструмент с адекватным дизайном.

[Примеры сборки доступны тут](./build-systems/meson).

### Bazel

Bazel -- система сборки от Google (so, _opinionated_).

Bazel написан на Java и дизайн рассчитан на распределённую сборку,
поэтому маленькие проекты могут страдать от оверхэда.

Отправная точка для сборки проекта при помощи Bazel -- файл `WORKSPACE`.
Директория с этим файлом считается "репозиторием". 
Внутри репозитория могут лежать пакеты -- папки с файлами `BUILD`,
в которых описаны таргеты для сборки.

Синтаксис опять напоминает Python (язык называется Starlark).
Можно расширять своими модулями, это отдельные файлы с расширением `.bzl`.

Совместимость с CMake даётся тяжело.

[Примеры сборки доступны тут](./build-systems/bazel).

## Пакетные менеджеры

> Так, мы наконец-то всё собрали, и оно вроде бы даже работает.
Теперь нам нужно автоматическое тестирование! Oh... Fuck, not again...

Писать всё с нуля (например, библиотеку для тестирования) можно, 
но не всегда нужно/хочется/есть на это время или силы или деньги.
В таких случаях можно воспользоваться чужими библиотеками/фреймворками, 
которых в open source огромное количество (или наработки другой команды внутри 
вашей общей кодовой базы; или проприетарный софт, если не повезло).

Однако, подключить внешнюю зависимость в C++ проект не так просто, 
как, например, в Python / JavaScript / Rust / Go / ... -- для этих языков 
существуют пакетные менеджеры 
[pip](https://pypi.org/project/pip/) 
/ [npm](https://www.npmjs.com/)
/ [cargo](https://doc.rust-lang.org/cargo/)
/ [go modules](https://go.dev/blog/using-go-modules) / ..., 
позволяющие одной командой подтянуть необходимую версию стороннего пакета.

### system

Некоторые зависимости можно подтянуть при помощи системы.
Например:

* Linux:
 
  ```shell
  apt install libboost-all-dev
  ```
  
* Mac:

  ```shell
  brew install boost
  ```

* Windows:

  ```shell
  ??? # lol who uses windows anyway
  ```

Но так лучше никогда не делать:

1. Как понять, что всё установилось правильно?
2. А если такая зависимость уже стояла, но другая версия?
3. Какая вообще версия поставится?
4. Что делать, если нужна свежая версия?

### Git

Git -- poor man's packet manager.
Git позволяет подцепить к репозиторию другой репозиторий в виде сабмодуля,
то есть вам доступны исходники нужной зависимости.

Дальнейшая сборка уже зависит от того, что поддерживает зависимость
(Makefile, CMake, Bazel, ...).
Большинство проектов собираются с CMake'ом, поэтому достаточно позвать
`add_subdirectory(submodule_dir)`, чтобы таргет зависимости стал доступен.

[Пример сабмодуля вместе с CMake](./dependencies/git).

### CMake

CMake попал в раздел "Пакетные менеджеры", откровенно говоря, номинально,
потому что менеджить пакеты в CMake -- то ещё удовольствие.

Для подтягивания зависимостей в CMake есть несколько возможностей:
* `git submodule` + `add_subdirectory()` -- собираем из исходников
* [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html) 
  -- ищем в системе (и молимся, чтобы нашлось)
* [`FetchContent()`](https://cmake.org/cmake/help/latest/module/FetchContent.html) 
  -- подгружаем из репозитория / по ссылке

В последних двух опциях CMake автомагически всё настраивает.

[Пример с `find_package` тут](./dependencies/cmake/find-package).

[Пример с `FetchContent` тут](./dependencies/cmake/fetch-content).

### Conan

Conan -- попытка сообщества соорудить свой собственный пакетный менеджер.
Пример "it just works", что довольно редкое явление для экосистемы C++.

Если описывать Conan вкратце, то это будет так:

* Кросс-платформенный
* Поддерживает все системы сборки (можно расширить на новую)
* Fine-grained настройка зависимостей (бинарники/исходники, компиляторы, etc.)
* Децентрализованная архитектура (можно создать свой репозиторий с пакетами)
* Бесплатный + лицензия MIT

У Conan есть глобальный репозиторий с доступными пакетами: 
https://conan.io/center/
Дальше нужно лишь найти нужный пакет и добавить его в специальный
`conanfile.txt` -- файл с TOML-like синтаксисом для описания зависимостей.

При этом Conan умеет генерировать необходимые команды системам сборки
(CMake, Bazel, ...), чтобы системы сборки могли подцепить предоставленные
Conan'ом зависимости.

[Пример использования.](./dependencies/conan)

### vcpkg

vcpkg -- пакетный менеджер от Microsoft.
В чём-то похож на Conan, но некоторые моменты сделаны кривовато (точно 
Microsoft разрабатывали).

Основные отличия от Conan:

* Поддерживает меньше операционных систем (в основном, Linux + Mac OS + Windows)
* Централизованный репозиторий пакетов
* Дружит с меньшим количеством систем сборки, сложнее расширить (если вообще 
  можно)
* Ручная настройка CMake 
* Сложно иметь одну и ту же зависимость разных версий
* Хуже кэширует
* Больше пакетов (?..)
* Лучше работает на Windows (?..)

[Пример использования.](./dependencies/vcpkg)

## Гибриды: системы сборки и пакетные менеджеры

### build2

build2 -- попытка создать `cargo` для C++.

Глобально есть несколько составляющих:

* build2 (b) -- система сборки
* bpkg -- пакетный менеджер
* bdep -- менеджер проекта

Для небольших проектов build2 будет скорее оверкилл.

Синтаксис довольно арканный, надо его изучать и привыкать к нему.

[Пример тут](./hybrids/build2).

### xmake

xmake -- кросс-платформенная система сборки вместе с менеджментом пакетов,
написанная на Lua.

xmake поддерживает много платформ и языков.
Синтаксис немного похож на Bazel/Meson, можно писать свои скрипты, 
есть REPL для дебага.

[Hello world](./hybrids/xmake/hello-world).

[Уже поддерживает модули!](./hybrids/xmake/modules) (build2, кстати, тоже)

[Работа с зависимостями](./hybrids/xmake/packages).

## Примеры проектов

### [Плохо](./project-examples/bad)

#### Плюсы

* Работает (возможно)

#### Минусы

* Как собрать?
* Хотя бы краткое описание?
* Без автоматических тестов любое изменение может всё сломать

### [Нормально](./project-examples/okay)

#### Плюсы

Всё, что выше, а также:

* Использование `namespace`-ов уменьшает шанс перекрыть код пользователя 
  своими символами
* Небольшой `readme.md` с полезной информацией
* Есть компилируемые примеры

#### Минусы

* `#pragma once` спасёт в большинстве случаев, но не во всех
* Торчат зависимости, которые можно было бы спрятать

### [Хорошо](./project-examples/good)

#### Плюсы

Всё, что выше, а также:

* Полноценный `readme.md` или wiki
* Наличие тестов и бенчмарков (если применимо) 
* Наличие конфигов `.clang-format` и `.clang-tidy`
* CI, который проверяет кодстайл и гоняет тесты

#### Минусы

* Единственный вариант подключения библиотеки -- через CMake

### [Отлично](./project-examples/great)

#### Плюсы

Всё, что выше, а также:

* (Крайне редко) У проекта нет своих зависимостей
* В CI гоняется матрица компиляторов и платформ + фаззинг
* Поддержка нескольких систем сборки
* Bindings для других языков
* Автоматическая генерация документации из комментариев (по типу doxygen) 
  с деплоем на условный GitHub Pages

## Материалы

### General

* [CppCon 2018: Mateusz Pusz “Git, CMake, Conan - How to ship and reuse our C++ projects”](https://www.youtube.com/watch?v=S4QSKLXdTtA)

### Make

* [Official site](https://www.gnu.org/software/make/)
* [Makefile tutorial](https://makefiletutorial.com/)

### Ninja

* [Official manual](https://ninja-build.org/manual.html#_philosophical_overview)
* [Building like (a) Ninja, pt.1](https://vector-of-bool.github.io/2018/12/20/build-like-ninja-1.html)

### CMake

* [Official docs](https://cmake.org/cmake/help/v3.22/)
* [Learning CMake](https://github.com/Akagi201/learning-cmake)
* [Modern CMake](https://cliutils.gitlab.io/modern-cmake/)
* [It's Time To Do CMake Right](https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/)
* [C++Now 2017: Daniel Pfeifer “Effective CMake"](https://www.youtube.com/watch?v=bsXLMQ6WgIk)
* [CGold: The Hitchhiker’s Guide to the CMake](https://cgold.readthedocs.io/en/latest/)

### Meson

* [Quickstart](https://mesonbuild.com/Quick-guide.html)
* [Simple tutorial](https://mesonbuild.com/Tutorial.html)
* [Manual](https://mesonbuild.com/Manual.html)

### Bazel

* [Getting started](https://docs.bazel.build/versions/4.2.2/getting-started.html)
* [C++ Tutorial](https://docs.bazel.build/versions/4.2.2/tutorial/cpp.html)
* [Core concepts and terminology](https://docs.bazel.build/versions/4.2.2/build-ref.html#concepts-and-terminology)
* [Distributed build](https://docs.bazel.build/versions/main/remote-execution.html)

### Conan

* [Conan cheatsheet](https://docs.conan.io/en/latest/_images/conan-cheatsheet.png)
* [CppCon 2016: Diego Rodriguez-Losada “Conan, a C and C++ package manager for developers"](https://www.youtube.com/watch?v=xvqH_ck-5Q8)

### vcpkg

* [Get started](https://vcpkg.io/en/getting-started.html)
* [Docs](https://vcpkg.io/en/docs/README.html)
* [Available packages](https://vcpkg.io/en/packages.html)

### build2

* [Official site](https://build2.org/)
* [CppCon 2018: “C++ Dependency Management: from Package Consumption to Project Development”](https://www.youtube.com/watch?v=Nni2Qu2WitY)

### xmake

* [Official site](https://xmake.io/#/)
* [Getting started](https://xmake.io/#/getting_started)
