# Идиома PImpl. Виртуальные функции, RTTI, паттерн visitor

- [Идиома PImpl. Виртуальные функции, RTTI, паттерн visitor](#идиома-pimpl-виртуальные-функции-rtti-паттерн-visitor)
  - [1. PImpl](#1-pimpl)
    - [1.1. Напоминание про компиляцию и сборку C++ кода. Рассказ про библиотеки](#11-напоминание-про-компиляцию-и-сборку-c-кода-рассказ-про-библиотеки)
    - [1.2. Какие проблемы создает описание класса в header-файле](#12-какие-проблемы-создает-описание-класса-в-header-файле)
    - [1.3. Реализация pImpl](#13-реализация-pimpl)
  - [2. Динамическая диспетчеризация](#2-динамическая-диспетчеризация)
    - [2.1. Механизм виртуальных функций](#21-механизм-виртуальных-функций)
    - [2.2. Показываем пример кода с разными флагами.](#22-показываем-пример-кода-с-разными-флагами)
    - [2.3. Ключевое слово `dynamic_cast`. Паттерн Visitor.](#23-ключевое-слово-dynamic_cast-паттерн-visitor)
    - [2.4. `typeid`, `std::type_info`.](#24-typeid-stdtype_info)
    - [2.5. _(Опционально)_ Дизайн: pImpl vs абстрактный базовый класс](#25-опционально-дизайн-pimpl-vs-абстрактный-базовый-класс)
  - [Дополнительные материалы](#дополнительные-материалы)

## 1. PImpl

### 1.1. Напоминание про компиляцию и сборку C++ кода. Рассказ про библиотеки

* Три этапа: препроцессинг, компиляция каждой единицы трансляции, линковка.
* Библиотеки либо целиком header-only ([RapidJSON](https://github.com/Tencent/rapidjson), [argparse](https://github.com/p-ranav/argparse)), либо предоставляются открытые header-ы и скомпилированная реализация для статической (`.a`) или динамической (`.so`) линковки. Часто поддержаны обе версии ([spdlog](https://github.com/gabime/spdlog), [libfmt](https://github.com/fmtlib/fmt)).
* Как мы привыкли делать: определение класса, описание всех полей и объявление методов в `.h`, определение - в `.cpp`.

### 1.2. Какие проблемы создает описание класса в header-файле

* Все заголовочные файлы транзитивно попадают в каждую единицу трансляции кода, который их включает. При любом изменении `.h`-файла полностью перекомпилируются все TU, которые от него зависят. Также увеличивается размер бинарника, если хедеры большие.
* Приватные члены классов доступны для просмотра пользователям библиотеки. Это может быть нежелательно по коммерческим причинам (когда библиотека предоставляется в уже собранном виде), а также из-за проникновения символов (разных внутренних классов и функций) в пространство пользователя, они становятся доступны при подсказках в IDE.

### 1.3. Реализация pImpl

Будем поэтапно писать pImpl для такого кейса: есть наш интерфейс для `StringSplitter`-а (удобный пользователям), который
под капотом использует boost (см. [pimpl/third-party](pimpl/third-party)) со всеми вытекающими последствиями. Избавимся
от boost-ового хедера в пользовательских файлах.

Сборка всех подпроектов через [CMake](pimpl/CMakeLists.txt), понадобятся хэдеры boost-а.

| №   | Где лежит код                              | Что происходит                                                                                    |
| --- | ------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| 0   | [pimpl/00-no-pimpl](pimpl/00-no-pimpl)     | вариант без pimpl, инклюд библиотеки в хедере                                                     |
| 1   | [pimpl/01-raw-ptr](pimpl/01-raw-ptr)       | pimpl на сыром указателе                                                                          |
| 2   | [pimpl/02-unique-ptr](pimpl/02-unique-ptr) | pimpl на `std::unique_ptr`, в комментариях еще см. про `std::shared_ptr`                          |
| 3   | [pimpl/03-fast-pimpl](pimpl/03-fast-pimpl) | fast pimpl (не аллоцируем в куче), валидация `sizeof` и `alignof` в compile-time (см. деструктор) |

## 2. Динамическая диспетчеризация

### 2.1. Механизм виртуальных функций

* Рассказать, что такое таблица виртуальных функций (хранит указатели на самый дочерний из доступных вариант метода, см. [картинку](images/vtable.png)).
* Реализация полиморфизма не специфирована в стандарте, но все делают через этот механизм.

### 2.2. Показываем [пример кода](https://godbolt.org/z/95WfsEz51) с разными флагами.

* На `-O0` видны реализации дефолтных конструкторов. Обратить внимание на то, что указатель на vtable кладется в начало класса.

* Показать, что код самих виртуальных функций `NameYourself()` не отличается от кода невиртуальной функции `NonVirtualMethod()`. Отличие в точке вызова `CallNameYourself()` - оно выполняется в три ассемблерные инструкции: прочтение указателя на vtable, прочтение адреса метода в таблице и собственно вызов метода.

* Показать, как располагаются друг относительно друга в vtable виртуальные методы базового класса и наследника (`IAmVirtualAsWell`).

* Переключиться на `-O2` и показать, что произошла _девиртуализация_: в данном случае возможно определить точные типы всех переменных во время компиляции и необходимость в рантайм диспетчеризации отпадает. Правда, тут еще и функции заинлайнены. Обсудить, когда такое невозможно.
  
### 2.3. Ключевое слово `dynamic_cast`. Паттерн Visitor.

* Сначала показать базовый пример работы с `dynamic_cast` [тут](01-event-dispatcher-dynamic-cast.cpp)

* Объяснить, почему конкретно эту задачу лучше решать через виртуальные функции (переписанный код [здесь](02-event-dispatcher-virtual-functions.cpp)).

* Рассказать, что в общем случае такой функциональности может не хватать:

  - Может не быть возможности произвольно менять код `Event`-ов, может не хотеться описывать в них сценарии обработки (а использовать просто как структуры для хранения контекста).

  - Эту задачу решает паттерн Visitor (переписанный код [здесь](03-event-dispatcher-visitor.cpp)). В этом паттерне можно научить `Event` отправлять указатель на себя в переданный ему "visitor", который получит доступ к контексту события и сможет его обрабатывать произвольным образом.
  
  - Обратить внимание, что в visitor происходит "двойная диспетчеризация" - механизм виртуальных функций срабатывает сначала в вызове `event->AcceptHandler()` (`IEvent`->реальный тип события), затем в `handler->Handle...()` (`IEventHandler`->`EventLogger`).
  
  - В visitor еще много forward declaration-ов, хороший повод про них еще раз напомнить.
  
* Стоит проговорить вслух, почему нет `dynamic_cast` по значению.

* Не всегда требует RTTI, upcasts выполняются в compile-time ([здесь](04-dynamic-cast.cpp)).

* Вернуться к примеру на godbolt из прошлого пункта и показать, что в vtable помимо указателей на методы есть еще `typeinfo`.
  
* _(Опционально)_ Обзорно про механику работы `dynamic_cast`:
  
  - простой каст (за константное время) к most-derived: `dynamic_cast<void*>`: смотрим в виртуальную таблицу, на которую указывает vptr. Там (возможно по offset) можно узнать most derived type. [Пример](05-dynamic-cast-voidptr.cpp)
    
  - sidecast и cast к произвольному дочернему в иерархии дорогие, делаются обходом некоего inheritance graph

* _(Опционально)_ `any` без RTTI ([fast dynamic cast](06-fast-dynamic-cast.cpp), [any without RTTI](07-any-no-rtti.cpp))

  - На самом деле, в `any` всегда делается каст к most-derived объекту.
  
  - Напомнить про инстанцирование шаблонов: для каждого шаблонного параметра будет своя копия функции в коде.
  
  - Делаем сравнение указателей на функцию `ptr_->GetTag() == &NoOp<T>` - она будет в единственном экземпляре в бинарнике и это валидно.

### 2.4. `typeid`, `std::type_info`.

* тоже не всегда требует RTTI. Для неполиморфных типов [эквивалентен](08-typeid-no-rtti.cpp) `typeid(decltype(expression))`.

* возвращает `const std::type_info&`.

### 2.5. _(Опционально)_ Дизайн: pImpl vs абстрактный базовый класс

* Indirection в обоих случаях. В pImpl за счет прокси-методов `pimpl_->MethodImpl()`, в `Abstract*` за счет виртуальных функций.

* pImpl неприменим, когда нужны шаблоны

## Дополнительные материалы

1) https://youtu.be/mkPTreWiglk?t=150 - хорошо про pImpl, fast pImpl
2) https://blog.panicsoftware.com/dynamic_cast-and-typeid-as-non-rtti-tools/ - почти весь код в dynamic оттуда
3) https://www.youtube.com/watch?v=QzJL-8WbpuU - механика `dynamic_cast`
4) https://shaharmike.com/cpp/vtable-part1/ - подробно про vtable, в том числе при множественном наследовании
