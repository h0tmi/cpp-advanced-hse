# Первый семинар
- представиться и познакомиться
- ответить на вопросы по лекции
- почему работать с new это полная *** [01-new-sucks.cpp](01-new-sucks.cpp)
- спросить и ответить на общие вопросы про std::unique_ptr/std::shared_ptr
  - если будет время, можно показать std::weak_ptr, вряд ли они его активно использовали [02-weak-ptr.cpp](02-weak-ptr.cpp)
  - тонкости обговорим в момент обсуждения большого дз
- на словах зачем может пригодиться MemoryPool [примеров кода нет]
  - интересные видео: [раз](https://youtu.be/nZNd5FjSquk), [два](https://youtu.be/LIb3L4vKZ7U)
- view [04-view.cpp](04-view.cpp)
  - поговорить про то, что объекты до 16 байт стоит передавать по значению
    - можно показать руками, во что превращается код, где передается через стек, а где через регистры
  - напомнить про lifetime, особенно временных объектов
- short string optimization [05-sso.cpp](05-sso.cpp)
  - показать руками хранимую подстроку в объекте
  - опционально рассказать трюк про то, как сделать 23 байта: храним в размере 23 - size
  - интересные особенности вместе со std::string_view
- выравнивание и иже с ним [06-padding-and-co.cpp](06-padding-and-co.cpp)
- placement new [07-placement-new.cpp](07-placement-new.cpp)
  - показать когда нужно: при работе с аллокаторами, да и любой неинициализированной памятью
  - особенности:
    - правильное выравнивание
    - ручной вызов деструктора
  - немного про const-init, как можно сделать глобальный буффер, чтобы потом положить в него какой-нибудь объект
- deque [теперь подробности есть в README задачи]
  - кольцевой буффер (храним указатели на начало и конец)
  - хотим, чтобы ссылки на объекты не менялись
  - можно хранить указатели, а не сами объекты
  - хотим разумную локальность данных
  - храним указатели на блоки по 512 байт
  - реаллокация в тот момент, когда указатели смотрят на один и тот же блок
    - выделяем в два раза больше блоков, как в векторе
    - перекладываем, следим, чтобы не было пропусков
    - добавляем новый блок в конец