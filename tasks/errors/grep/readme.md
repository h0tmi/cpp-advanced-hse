# Grep

В этой задаче вам предстоит реализовать часть функциональности утилиты `grep`. Для этого напишите функцию
`Grep(path, pattern, visitor, options)`, которая рекурсивно перебирает все файлы в `path` и ищет в каждом вхождения строки `pattern`.

Если `path` указывает на файл, то функция должна работать с этим файлом, а если на директорию, то рекурсивно обойти все ее содержимое.
В процессе работы с файлами игнорируйте симлинки и специальные файлы. Для работы с файловой системой используйте
`<filesystem>` (документация https://en.cppreference.com/w/cpp/filesystem). Обратите внимание, что это уже часть
стандартной библиотеки в С++17.

В параметре `visitor` передается объект-визитор, т.е. используется [одноименный паттерн](https://habrahabr.ru/post/208718/).

В процессе работы `Grep` должен как-то сохранять найденные совпадения. Для наибольшей гибкости в данном случае используется упомянутый
паттерн. Если найдено очередное вхождение шаблона в файле `file` в строке `line` в позиции `column`, то вызывается метод
`OnMatch(file, line, column, context)` визитора, а он уже сам решает, что делать с этим совпадением. Последний аргумент описан далее.
В данной реализации мы используем статический полиморфизм, т.е. мы принимаем шаблон визитора в функции.

`options` регулирует поведение `Grep`. В параметре `max_matches_per_line` хранится максимальное число совпадений в одной строке, которое
нужно учитывать. Параметр `look_ahead_length` хранит, сколько символов после совпадения нужно передать в последнем аргументе `OnMatch`.
Обратите внимание, что этот параметр имеет тип `optional`. Если его значение `nullopt` (т.е. фактически
отсутствие значения), то его же и нужно передавать в `OnMatch`. В противном случае нужно передать подстроку указанной длины.
Если после вхождения в строке остается меньше символов, чем указано в параметре, просто возьмите всю часть строки до конца.

Функция должна корректно работать не только с ascii-символами, но и с utf-8. Это касается как имен файлов, так и их содержимого.
Для этого используйте библиотеку [для работы с utf-8](http://utfcpp.sourceforge.net/). Она уже есть в файлах задачи. Про UTF8 почитайте самостоятельно, если что-то не поймете - приходите в чат.

Также ваша функция не должна бросать исключений. Возможны следующие ошибки:

* не удалось открыть файл (например, нет прав на чтение)
* в процессе чтения файла произошла ошибка (например, он записан не в utf-8).

В этих случаях нужно позвать метод `OnError` визитора, куда передать причину ошибки, и пропустить данный файл. Если права на чтения
отсутствуют у директории, то просто пропускайте ее, не вызывая данный метод.

Для эффективного поиска подстроки в строке используйте
[алгоритм Бойера-Мура](https://en.cppreference.com/w/cpp/utility/functional/boyer_moore_searcher), который появился в С++17
(см. примеры).

Номера строки и столбца у вхождений начинаются с 1.

В этой задаче отключен линтер, т.к. нам не хочется возиться с utf8.h.

Обратите внимание, что тесты нужно запускать из директории с задачей.
