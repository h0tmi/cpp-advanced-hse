# Safe transform

Реализуйте функцию `TransformIf(begin, end, p, f)`, которая принимает 2 итератора, задающие последовательность,
унарный предикат `p` и функтор `f`, и применяет данный функтор ко всем элементам последовательности, для которых выполнен заданный
предикат. Считается, что `f` модифицирует переданный элемент (принимает по ссылке), поэтому данная функция в отличие от
`std::transform` работает in-place.

Обозначим за `T` тип элементов последовательности. Для упрощения в этой задаче не используется move-семантика.
Вы можете считать, что у `T` определен конструктор копирования и оператор присваивания.

Ваша функция должна вести себя атомарно --- либо полностью модифицировать последовательность, либо оставлять ее в исходном состоянии
(при возникновении исключений). Для этого держите лог всех измененных элементов (для которых выполнен предикат) и при исключении
восстанавливайте последовательность в исходное состояние при помощи лога. Не копируйте всю последовательность заранее.

Если точнее, функция должна гарантировать следующее:

* Если `p` и/или `f` бросает исключение, то функция должна оставить последовательность в первоначальном виде (и бросить то же исключение).
* Если при копировании `T` возникает исключение, а `p` и `f` исключений не бросают, то функция должна отрабатывать полностью
(и не бросать исключений).
* Если исключения возникают и при копировании `T`, и в `p` и/или `f`, функция оставляет последовательность в неопределенном состоянии
и бросает одно из исключений.
