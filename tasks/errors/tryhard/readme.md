# Try

В этой задаче вам предстоит реализовать класс `Try<T>`, содержащий внутри себя либо значение типа `T`, либо исключение, либо ничего,
а также функцию `TryRun`, которая запускает переданную ей функцию и возвращает `Try<T>`, при необходимости поймав исключение.

Класс `Try<T>` должен содержать следующее:

* Конструктор по умолчанию (это означает, что объект пустой).
* Конструктор, принимающий значение типа T.
* Конструктор, принимающий произвольное исключение, который сохраняет в классе _причину_ исключения.
* Константный метод `Value`, возвращающий `const T&`. Если в классе было сохранено какое-то исключение, метод должен бросить его.
Если же класс пустой, то метод также должен бросить любое исключение, производное от `std::exception` с текстом "Object is empty".
* Метод `Throw`, который бросает сохраненное исключение. Если же такого нет, то бросает исключение, производное от `std::exception` с
тектом "No exception".
* Константный метод `IsFailed`, который возвращает `true`, если в объекте сохранено какое-то исключение.

Помимо этого в вашем решении должна быть отдельная специализация `Try<void>`, которая не содержит метода `Value` и соответствующего
конструктора.

Реализуйте также функцию-обертку `TryRun`, приведенную в `try.h`. Данная функция запускает переданную функцию с переданными аргументами,
возвращая `Try` в качестве результата. При этом:

* Возвращаемый тип `Try<T>` совпадает с возвращаемым типом обернутой функции (в коде вы можете увидеть, как можно определить тип `T`).
* Если функция бросила исключение, то:
    * Если это исключение, производное от `std::exception`, то его нужно сохранить в `Try`, при этом когда `Try` попросят бросить
    это исключение (например, через `Throw`), она должна бросить повторно тот же объект, что был пойман в `TryRun`. Для реализации вам понадобится класс
[std::exception_ptr](http://en.cppreference.com/w/cpp/error/exception_ptr).
    * Если это `const char * `, то необходимо запомнить только _причину_ ошибки (в данном случае этот `const char * `),
    а `Throw` в `Try` может бросать новый объект.
    * Если это `int`, то все аналогично предыдущему пункту. При этом считается, что данный `int` обозначает код системной ошибки,
    и можно использовать `std::strerror`, чтобы узнать причину.
    * Если это какое-то иное исключение, то в `Try` нужно сохранить произвольный `std::exception` с текстом "Unknown exception".

### Примечания

* Постарайтесь обойтись без дублирования кода при реализации `Try<T>` и `Try<void>`, для этого вам может пригодиться закрытое
наследование.
* Вы можете увидеть, что `TryRun` может принимать произвольное число аргументов. Для этого используются variadic templates.
В решении делать с ними ничего помимо `func(args...)` не нужно.
* Постарайтесь обойтись без дублирования кода при реализации `TryRun<T>` и `TryRun<void>`. Подумайте, как можно использовать
механизм частичной специализации шаблонов.
