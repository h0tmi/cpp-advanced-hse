# Коровий вектор

Стандартный вектор реализует, так называемую, _value-семантику_. Это
значит, что при копировании вектора копируются все значения, хранящиеся
в векторе. Такое поведение называют еще "глубокое копирование".

Семантика копирования вектора проста для понимания, но может быть довольно
затратной. Поэтому при работе с вектором нужно писать код аккуратно,
чтобы не создавались лишние копии вектора там где это не нужно.

Кроме _value-семантики_, можно выделить два других подхода.
 - _reference-семантика_ - при копировании объекта, его содержимое никогда
   не копируется, а всегда делится между всеми копиями. Этот подход иногда
   называют "поверхностное копирование" или "shallow copy".
 - _cow-семантика_. COW расшифровывается как "copy-on-write". В этом
   подходе мы изначально делаем shallow copy вектора. Если пользователь
   только читает содержимое копии и никак её не модифицирует, то он
   и не замечает подмены и мы экономим затраты. В тот момент, когда
   пользователь пытается совершить модификацию вектора, мы делаем настоящую
   "глубокую копию". Таким образом, копирование совершается только при
   записи в вектор. Отсюда и название "copy-on-write".

COW семантика применяется в реализации строк яндекса и facebook-а.

## Реализация

Для реализации COW семантики вам потребуется вынести все поля вашего вектора
в отдельную структуру. Внутри этой структуры кроме обычных полей нужно хранить
еще счётчик ссылок.

```c++
struct State {
    int ref_count; // сколько векторов делят этот State между собой.
    
    // другие поля
};

class COWVector {
private:
    State* state_;
};
```

Правильно поддерживая `ref_count`, вы всегда будете знать, когда нужно удалять
`State` или когда нужно превращать shallow-copy в deep-copy.

## Замечания

* В данной задаче запрещено использовать `std::shared_ptr`.
* Внутри `State` вы можете использовать `std::vector`, реализовывать свой не нужно.
