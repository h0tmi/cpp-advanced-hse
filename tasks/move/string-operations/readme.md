# String operations

В этой задаче вам предстоит написать очень много оптимальных функций для работы со строками.

Первое, что надо сделать это вспомнить лекцию, но на всякий случай надо уметь разделять — [`std::string`](http://en.cppreference.com/w/cpp/string/basic_string_view) и [`std::string_view`](http://en.cppreference.com/w/cpp/string/basic_string_view).

Мы предлагаем вам реализовать много функций для работы со строками, где надо выбрать, что из `std::string`, `std::string_view` надо использовать в аргументах и возвращаемом значении. В спецификации всё будет заменено на `STR`, вам надо будет самим выбрать для каждого вхождения, на какой тип заменить. Используйте максимально оптимальные выборы строк по следующей метрике

1. Корректность кода.
2. Минимально возможное количество аллокаций без предположения об [оптимизации малых строк](https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/).
3. Минимальное возможное "разумное" количество CPU циклов.

Все условия проверить достаточно сложно автоматически, поэтому тестер может показаться вам ужасным. Заодно, если хотите реверсить из тестов, почитаете много интересного кода. В тестах пересечение всех условий даёт правильные сигнатуры и имплементации, но каждое условие по отдельности может разрешать бОльшую вариативность, чтобы вы глупо не списывали с тестов.

Как обычно, если код нешаблонный, имплементацию надо писать в .cpp файле, а сигнатуры можно указать в .h файле.

`bool StartsWith(STR string, STR text)` — проверяет, что строка `string` начинается с `text`.

`bool EndsWith(STR string, STR text)` — проверяет, что строка `string` оканчивается на `text`.

`STR StripPrefix(STR string, STR prefix)` — возвращает `string` с убранным `prefix`,
если `string` не начинается на `prefix`, возвращает `string`.

`STR StripSuffix(STR string, STR suffix)` — тоже самое, но с суффиксом.

`STR ClippedSubstr(STR s, size_t pos, size_t n = STR::npos)` — тоже самое, что и `s.substr(pos, n)`,
но если `n` больше `s.size()`, то возвращается `s`.

`STR StripAsciiWhitespace(STR)` — `strip` строки, удаляем все символы с обоих концов
вида [isspace](https://en.cppreference.com/w/cpp/string/byte/isspace).

`std::vector<STR> StrSplit(STR text, STR delim)` — делаем `split` строки по `delim`. Подумайте, прежде чем копипастить из уже имеющейся задачи. Обойдитесь одной аллокацией памяти.

`STR ReadN(STR filename, int n)` — открывает файл и читает `n` байт из filename. Используйте Linux Syscalls `open`, `read`, `close`. Если открыть или прочитать файл нельзя, возвращает пустую строчку.

`STR AddSlash(STR path)` — добавляет к `path` файловой системы символ `/`, если его не было.

`STR RemoveSlash(STR path)` — убирает `/` из `path`, если это не сам путь `/` и путь заканчивается на `/`.

`STR Dirname(STR path)` — известно, что `path` — корректный путь до файла без слеша на конце, верните папку, в которой этот файл лежит без слеша на конце, если это не корень.

`STR Basename(STR path)` — известно, что `path` — корректный путь до файла, верните его название.

`STR CollapseSlashes(STR path)` — известно, что `path` — корректный путь, но `/` могут повторяться, надо убрать все повторения.

`STR StrJoin(const std::vector<STR>& strings, STR delimiter)` — склеить все строки в одну через `delimiter`.
Обойдитесь одной аллокацией памяти.

`STR StrCat(Args...)` — склеить все аргументы в один в их строковом представлении. Должны поддерживаться числа (`int, long, long long` и их `unsigned` версии), также все строковые типы (`std::string, std::string_view, const char*`). Аргументов в `StrCat` будет не больше пяти. Придумайте как это сделать за одну аллокацию памяти.

* В этой задаче нельзя пользоваться `std::to_string`, а также методами `starts_with` и `ends_with`.
* В функции `StrCat` вам потребуется принимать заранее неизвестное число аргументов. Реализовывать перегрузки функции для разного числа аргументов, конечно, не стоит. Вместо этого предлагается воспользоваться синтаксисом [variadic templates](https://en.cppreference.com/w/cpp/language/parameter_pack), который также будет разбираться на лекции. Также обратите внимание на [fold expressions](https://en.cppreference.com/w/cpp/language/fold) - так код получится совсем понятным.
