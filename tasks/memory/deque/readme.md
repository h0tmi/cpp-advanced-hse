# Deque

В этой задаче вам нужно реализовать упрощенный аналог шаблонного класса `std::deque`, а именно дек с типом элементов `int`.

## Как решать эту задачу?

Мы будем реализовывать дек как расширяемый кольцевой буфер блоков фиксированного размера.

По сравнению с вектором дек отличается требованием уметь вставлять и удалять из начала за О(1), поэтому нужно научиться "выделять память в начале". Для этого вместо непрерывной области памяти будем заполнять блоки фиксированного размера, храня ссылки на блоки в отдельном контейнере. Этот контейнер должен поддерживать операции "создать элемент слева" и "создать элемент справа", чтобы выделять блоки при вставке в начало и в конец.

В качестве такого контейнера будем использовать *кольцевой буфер* - массив фиксированного размера, в котором считается, что последний элемент стоит "слева" от начального. В кольцевой структуре можно считать "начальным" любой элемент буфера, а также у любого элемента есть левый и правый сосед.

### Процедура вставки элемента

Допустим, что размер блока - 16 байт, то есть, 4 элемента типа `int`. При вставке первого элемента создастся первый блок и в его начале разместится элемент. Если затем еще трижды позвать `push_back`, то 3 новых элемента запишутся подряд в этот же блок. Пятый элемент в блок уже не вмещается - поэтому выделяем новый, кладем элемент в его начало и сохраняем ссылку на новый блок справа от первого.

Пусть теперь пришел запрос на вставку в начало. Что делать? Выделим еще один блок и положим элемент в его конец. Также сохраним ссылку на новый блок слева от начального и запомним, что начальный блок теперь другой.

При запросе на получение элемента по индексу можно отвечать за О(1) - нужно лишь корректно вычислить блок, в котором находится элемент, и адрес элемента внутри него.

### Расширение кольцевого буфера

Осталась еще одна проблема — кольцевой буфер создается статического размера, а значит количество элементов в деке получается ограниченным. Здесь вам нужно расширить функционал обычного кольцевого буфера и реализовать его реаллокацию со страгегией x2 (как в векторе). Важно понимать, что при этом реаллоцируется **только буфер с указателями на блоки**, но не элементы - а значит не инвалидируются и ссылки на них.

### Размер блока

Конечно, использовать на практике блоки размером 16 байт неэффективно - так у вас получится слишком большой кольцевой буфер. В этой задаче используйте блоки размером 512 байт.

## Интерфейс

* Конструктор по умолчанию.
* Конструктор, принимающий размер деки и заполняющий её нулями.
* Конструктор, принимающий список инициализации `std::initializer_list<int>`, что позволяет писать `Deque a{1, 3, 5}`.
* Конструкторы копирования и перемещения.
* Операторы присваивания, копирующий и перемещающий.
* Деструктор.
* Метод `Swap`, принимающий другую деку по ссылке и меняющий содержимое текущей деки с ним местами.
* Операторы индексирования [ ], константный и нет. Последний должен позволять изменять содержимое по индексу.
* Метод `Size`, возвращающий число элементов в деке.
* Метод `PushBack`, который вставляет элемент в конец деки. Если при этом в конце последнего блока нет свободных ячеек, то выделите новый блок и положите новый элемент туда.
* Метод `PopBack`, который удаляет последний элемент деки. Если удаляется последний элемент в блоке, то блок нужно удалить.
* Аналогичные методы `PushFront` и `PopFront`.
* Метод `Clear`, опустошающий деку. `Size` должен стать нулевым.

### Примечания

* Обратите внимание, что сложность операций `PushFront`/`PopFront` должна составлять O(1) в отличие от вектора.
* Операция индексации также должна работать за O(1).
* Важное требование --- все ссылки на элементы дека должны оставаться валидными при вставках/удалениях в дек (кроме ссылок на удаляемые элементы, конечно). Стандартный `std::deque` тоже удовлетворяет этому требованию.
* В этой задаче [запрещено](.tester.json) использование стандартных контейнеров.
