# Matrix 2.0

В этой задаче мы посмотрим, ~~какой треш можно творить~~ какие широкие возможности открывают шаблоны в С++.
Мы хотим оптимизировать последовательность матричных умножений. Допустим есть следующий код:

```
Matrix D = A * B * C;
```

Допустим матрицы имеют размеры $`A_{50 \times 5}, B_{5 \times 100}, C_{100 \times 10}`$. Тогда в силу ассоциативности умножения
матриц, результат можно посчитать двумя способами:

```math
D = (AB)C  \;\;\; D = A(BC)
```

Причем в первом случае мы сделаем $`50 \cdot 5 \cdot 100 + 50 \cdot 100 \cdot 10 = 75000`$ скалярных умножений, а во втором
$`5 \cdot 100 \cdot 10 + 50 \cdot 5 \cdot 10 = 7500`$, т.е. в 10 раз меньше. Наша задача --- реализовать * для Matrix таким образом,
чтобы последовательность перемножений была оптимальной.

### Пролог

Для начала вам понадобится класс `Matrix`, подобный тому, который вы реализовали в задаче [matrix](https://gitlab.com/slon/shad-cpp0/tree/master/matrix). Параметризуйте его типом хранящихся элементов `T`. Реализуйте все те же методы, что и в прошлой задаче, за исключением
функций `Transpose`, `Identtity`, а также присваивающих операторов `+=,-=,*=`, которые мы здесь не используем.

Не реализуйте пока оператор `*`. Обратите внимание, что имеет смысл реализовать `+,-` как друзья класса, причем определить их
**внутри** класса. Нам это понадобится в дальнейшем.

### Первый шаг

Проблема в том, что в языке жестко зафиксировано, что оператор `*` левоассоциативен, т.е. компилятор всегда будет раскрывать его как
`((A*B)*C)*D`, и с этим ничего нельзя сделать. Нам же нужно каким-то образом получить весь список операндов (A, B, C, D), который потом
вычислить в оптимальном порядке. Можно сделать такой оператор умножения, который сохраняет внутри себя информацию о двух операндах.
Определим структуру, которая содержит пару ссылок на левый и правый аргументы:

```c++
struct Glue {
    Glue(const Matrix& l, const Matrix& r) : left(l), right(r) {
    }

    const Matrix& left;
    const Matrix& right;
};
```

Тогда можно определить оператор умножения следующим образом:

```c++
Glue operator*(const Matrix& left, const Matrix& right) {
    return Glue(left, right);
}
```

Проблема теперь в том, что такой `*` работает только для двух аргументов. Т.е. для цепочки (A * B) * C нам нужен еще такой `*`, который
принимает уже `Glue` и `Matrix`, причем в результирующем `Glue` такого `*` левый операнд `left` должен уже иметь тип `Glue`, а не
`Matrix`. Как этого добиться? Давайте параметризуем `Glue` типами левого и правого аргументов, т.е. `Glue<L, R>`. Аналогично поступим
с оператором `*`. Реализуйте шаблонную версию `Glue` и оператора `*`. В этом случае для `A * B * C * D` результат будет иметь тип

```
Glue<Glue<Glue<Matrix, Matrix>, Matrix>, Matrix>
```

### Обход дерева

Таким образом все аргументы `*` у нас сейчас хранятся в подобном дереве:

```
    Glue
   /    \
  Glue   D
  /   \
 Glue  C
 /  \
A    B
```

Стоит понимать, что это дерево строится самим компилятором на этапе компиляции. Теперь научимся выписывать все листовые узлы такого
дерева, что нужно для того, чтобы получить список всех матриц, участвующих в произведении.
Это выписывание и последующее вычисление разумно делать в соответствующем конструкторе Matrix. Например, пусть мы пишем

```c++
Matrix<int> e = a * b * c * d;
```

Тогда как мы уже видели, тип выражения справа от `=` это какой-то `Glue`, и мы зовем конструктор `Matrix` с `Glue`, т.е. нужно определить

```c++
template <class L, class R>
Matrix(const Glue<L, R>& tree);
```

Теперь нужно обойти это дерево и выписать все листья. Мы хотим сделать это на этапе компиляции, т.е. чтобы в сгенерированном коде
матрицы уже лежали в одном списке. Поскольку дерево строится на этапе компиляции, их количество тоже должно быть известно, а значит
мы можем завести массив типа `const Matrix* operands[count]`, в который мы запишем указатели на все наши матрицы.
Задача в том, чтобы вычислить `count`.

Для этого нужно реализовать простую метафункцию. Посмотрите и разберитесь с примером с факториалом [здесь](https://en.wikipedia.org/wiki/Template_metaprogramming). Вам нужна подобная функция, в нашем случае базовый вариант будет такой:

```c++
template <class T>
struct GetCount<Matrix<T>> {
    static const int kCount = 1;
};
```

Соответственно вам нужно дописать частичную специализацию для `Glue`. После того как мы вычислили `count` и создали массив, этот массив
нужно заполнить. Для этого вы снова можете написать подобную метафункцию, но можно поступить проще, используя `constexpr` функции.
Вы можете самостоятельно почитать про `constexpr`. В текущей версии стандарта вы более-менее пишите функцию как обычно, но дописываете
в начале ключевое слово `constexpr`, после чего функцию можно использовать на этапе компиляции.

При использовании метафункций в стиле `GetCount` мы полагаемся на механизм частичной специализации шаблонов. Чтобы делать подобное в
`constexpr` функции, вам нужно аналогично реализовать перегрузку, принимающую `Matrix`, и перегрузку, принимающую `Glue`. Т.е. в данном
случае используется механизм перегрузки функций.

### Оптимизация умножений

После того, как вы выписали все матрицы (а точнее указатели на них, чтобы не копировать лишнего) в массив, можно определить оптимальный
порядок вычислений. Для этого воспользуйтесь [динамическим программированием](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86).

Перед тем, как начать это делать, стоит проверить, что все размеры матриц совместимы. Если это не так, нужно бросить исключение типа
`std::runtime_error`.

### Смешанные операции

Если вы все сделали правильно, то у вас будут работать и выражения вида
```c++
Matrix<int> a = b * c + d * e;
```

Даже несмотря на то, что оператор `+` не принимает `Glue`. Тут стоит вспомнить, что конструктор `Matrix(Glue)` не `explicit`, поэтому
компилятор выполняет неявное преобразование типа (причем вычисляя по ходу результат умножения). В контексте шаблонов такое неявное
преобразование будет происходить только в том случае, если оператор объявлен как внешняя функция, но внутри класса. Объявить функцию
как внешнюю, но внутри класса, можно только с помощью `friend` и только реализовав ее прямо в классе. Подробнее читайте у Майерса.

### Последний штрих

На самом деле с нашим оператором `*` есть небольшая проблема --- он принимает аргументы произвольных типов `L` и `R`, после чего
склеивает их в `Glue<L, R>`. Проблема в том, что теперь такой оператор определен и для `std::string * std::string`, что неправильно.

Нам нужно как-то обозначить, что `L` и `R` это либо `Matrix`, либо произвольный `Glue`. Для этого воспользуемся идиомой
[CRTP](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern). В нашем случае нужно унаследовать `Matrix` и `Glue` от
`Base`, параметризованный типами наследников. Теперь в операторе `*` можно принимать `Base`. Особенность `CRTP` по сравнению с обычным
наследованием в том, что мы знаем реальный тип `Base` на этапе компиляции (он зашит как параметр шаблона в тип `Base`), соответственно
в `*` нужно только вытащить этот реальный тип с помощью `static_cast`.
