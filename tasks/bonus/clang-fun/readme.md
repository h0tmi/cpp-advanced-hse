# Clang tooling

В этой задаче от вас требуется написать небольшую утилиту с использованием clang tooling: https://clang.llvm.org/docs/LibTooling.html.

Если вы работаете на ubuntu, то поставьте пакеты `llvm-14-dev` и `libclang-14-dev` (или более свежих версий).

Утилита должна проверять имена, используемые в коде, на соответствие Google Styleguide, а также искать потенциальные опечатки в этих
именах.

Решение реализуйте в файле `check_names.cpp`. Вы можете создавать произвольные .h файлы, они также будут отправлены на сервер.

## Styleguide

Имена сущностей в коде должны соответствовать описанным здесь правилам: https://google.github.io/styleguide/cppguide.html#Naming.
Впрочем, есть некоторые отличия и исключения:

1. Нужно проверять только имена переменных, членов классов, типов, констант, функций и перечислений.
2. Для констант и constexpr переменных всегда используется стиль kConstName, даже если это член класса.
3. Есть отдельное правило для заглавных букв в тех именах, где они допустимы (т.е. не в именах переменных, членах классов). В имени
могут встречаться последовательности из заглавных букв, при этом их длина должна быть не меньше 3 без учета начала следующего слова.
Например, `BuildDSUnion` невалидное имя, т.к. длина `DS` равна 2, а `U` начинает следующее слово. `BuildDSU` или
`CreateASTMatcher` --- примеры валидных имен. Имя не может целиком состоять из заглавных букв.
4. В именах всех сущностей запрещены цифры.

Разумеется, нужно реагировать только на объявления сущностей.

Это учебная задача --- в реальности `clang-tidy` умеет проверять имена на соответствие стайлгайду.

Обратите внимание, что ваш собственный код должен проходить вашу же проверку --- это проверяется в тестах.

## Поиск опечаток

Вашей программе может быть передана опция `-dict path_to_dict`, где `path_to_dict` --- словарь, текстовый файл, в каждой строке которого
записано одно слово. В этом случае ваша утилита также должна производить поиск опечаток. Если переменная удовлетворяет правилам выше,
то для каждого слова в ее имени нужно поискать "ближайшее" к нему из словаря. В качестве меры близости используется
[расстояние Левенштейна](https://en.wikipedia.org/wiki/Levenshtein_distance). Пусть слово из имени `x`, ближайшее к нему `y`,
а `d(x, y)` --- расстояние между ними.
Тогда опечаткой считается случай `0 < d(x, y) < 4`. В рамках данной задачи от вас не требуется реализовывать поиск ближайшего слова
эффективно, поэтому можете использовать простой линейный поиск по словарю. Проверку нужно делать только для слов длины > 3.

## Тестирование

Тесты находятся в `tests`. Там же в файлах `result.txt` записаны правильные (наверное) ответы на них. Тесты запускаются с помощью скрипта
`run_tests.sh`. Скрипт просто посимвольно сравнивает вывод вашей программы и правильный (с помощью `diff`), поэтому важно
использовать правильный формат вывода. Для вывода используйте функции из `print.h`:

Скрипт должен запускаться из директории с исходным кодом. Скрипт ожидает, что билд директория находится в `build/release`, но вы можете
изменить переменную B в скрипте на вашу билд директорию.

1. После обработки очередного файла вызовите `PrintStatistics`.
2. Далее используйте функции `BadName` и `Mistake` для вывода произошедших в ходе обработки файла событий.

Если одно и то же событие случилось несколько раз, например, переменная с невалидным именем объявлена несколько раз --- такое
может быть в случае static-членов класса, выводите информацию о каждом событии. Если ближайших слов к данному несколько, берите
первое по порядку в словаре.

Ваша программа всегда должна завершаться с нулевым кодом возврата (даже в случае наличия ошибок), а весь вывод должен идти в stdout.

По данному заданию не будет ревью, однако мы выборочном просмотрим некоторые посылки на предмет наличия ~~bullshit'а~~
интересных решений.

