# Hack CPP

В С++ есть множество самых разнообразных конструкций: разделение методов на public, protected и private, полиморфизм, перегрузка функций, шаблонные специализации, метапрограммирование, встроенная поддержка корутин, ассемблерные вставки, многопоточное программирование, барьеры памяти и еще много всего интересного. Чтобы в этом всем разобраться необходимо смотреть лекции, делать домашки и читать ~~stackoverflow~~ [cppreference](https://en.cppreference.com/w/). Однако в программировании нету лучше способа в чем-то досканально разобраться, чем это что-то взломать. В этой задаче вам предлагается hack'нуть некоторые конструкции языка, так сказать, в подтверждение своих знаний.

## Public, Protected & Private
Одним из основных принципов объектно-ориентированного программирования является инкапсуляция, используемая для сокрытия внутренних деталей объекта и для предотвращения несанкционированного доступа к его состоянию. Разделение методов на public/protected/private позволяет нам скрывать внутренний функционал класса, который не должен быть доступен извне. Однако что делать, если метод приватный и менять код класса мы не хотим, а вызвать этот метод очень-очень хочется? Например, вы хотите провести unit-тестирование всех методов вашего класса (даже приватных), или вы злостный хакер который хочет заполучить какие-то суперсекретные данные из приватных полей. Так или иначе, в этой части задания вам предстоит научиться вызывать приватные методы класса, как если бы они были публичными.

Разумеется, достать приватные методы из класса непросто. Поэтому, перед тем начать "ограбление", вы можете попытаться извлечь из класса столько информации, сколько сможете унести. А именно, вам нужно реализовать макрос `PREPARE_FOR_ROBBERY`, который принимает имя класса, имя метода, который хотим вызвать, и его сигнатуру. Например, если ваш класс имеет такой вид,


```c++
class MyClass {
    int foo(double, float);
};
```
и вы собираетесь взломать метод foo, то в перед взломом вы должны вызвать:
```cpp 
PREPARE_FOR_ROBBERY(MyClass, foo, int, double, float);
```

Когда подготовка закончена, мы начинаем "грабить" класс. Этот функционал (если ограбление, конечно, можно так назвать) вам нужно реализовать в макросе `ROB`. В него передается объект, методы которого мы взламываем, имя класса, имя метода, и аргументы которые принимает этот метод. Проводя аналогию с примером выше, вызов мог бы быть таким:
```cpp
ROB(myclass, MyClass, foo, 42.0, 10.0f);
```

`Spoiler 1`: Не нужно пугаться макросов в этой задаче. Они здесь нужны только для того, чтобы обобщить логику взлома на любой класс и любой метод.

`Spoiler 2`: Даже не пытайтесь заслать решение, похожее на то, что ниже. Ваши баллы неизбежно превратятся в 0.
```cpp
#define private public
// or
#define class struct
```

## Polymorphism
В C++ полиморфизм достигается с помощью виртуальных функций и наследования. В основе полиморфизма лежит возможность использовать указатели и ссылки базового класса для работы с объектами производных классов. Такой подход позволяет создавать абстракции над абстракциями, строить очень гибкую архитектуру и казалось бы вообще горя не знать. Однако, в этой части задания вам нужно доказать, что все-таки можно познать горя используя полиморфизм в С++ как он есть.

Вам нужно написать функцию `TrapObject` которая принимает 3 аргумента: ссылку на объект, имеющий хотя бы одну виртуальную функцию, количество виртуальных функций у этого объекта, и `trap`-функцию. `TrapObject` может делать какие угодно преобразования над переданным в нее объектом, может даже отформатировать жесткий диск вашего компьютера, но главное -- по результату ее выполнения все виртуальные функции объекта не должны выполняться; вместо них должна быть вызвана `trap`-функция. То есть, после вызова `TrapObject`, каждый вызов виртуальной функции должен приводить к вызову `trap`-функции. В случае если условие вам все еще непонятно, смотрите тесты -- они четко отражают суть задания.

## Тестирование

В задаче собираются два таргета -- `test_call_private` и `test_polymorphism`. Для успешной сдачи вам нужно сделать обе подзадачи.
