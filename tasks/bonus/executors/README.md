# Executors framework

## Введение

В предыдущих задачах вам нужно было распараллелить вычисления. Если немного обобщить, то код всех ваших решений выглядел примерно так:

```c++

class Output;
class Input;

Output Compute(const Input& inputs) {
    // Select concurrency level
    int num_threads = std::thread::hardware_concurrency();

    // Split input into tasks
    std::vector<Tasks> tasks = SplitIntoSubtasks(inputs, num_threads);

    // Launch threads
    std::vector<std::thread> threads;
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([i, &inputs, &tasks] {
            ComputeSubtask(&tasks[i], input);
        });
    }

    // Join all threads
    for (auto& t : threads) t.join();

    // Aggregate
    return Aggregate(tasks, input);
}
```

Если внимательно посмотреть на код, то можно заметить, что в нём смешаны 2
независимых действия:
  
  1. Большая задача разбивается на небольшие независимые подзадачи. Затем
      решения подзадач объединяются вместе. Этот код специфичен для каждого алгоритма.

  2. Код решает сколько потоков запускать, как их запускать и когда
      их завершать. Этот код везде одинаковый.

С первым пунктом все хорошо, а вот со вторым есть проблемы.

* Пользователь не может контролировать сколько потоков будет запущено.
  _Код действует эгоистично и занимает все ядра на машине._

* Неудобно использовать такой код внутри другого параллельного алгоритма.
  _Например если на первом уровне разобъем задачу на 10 частей и каждую захотим решить с помощью `Compute()`, то у нас запустится `10 * hardware concurrency` потоков._

* Нельзя отменить вычисление, нельзя следить за прогрессом.

Все проблемы появляются из того, что код сам занимается созданием
потоков. Мы хотим вынести это решение на самый высокий уровень, а в
коде оставить только разбиение на независимые подзадачи. В этом
задании вам нужно написать библиотеку помогающую выполнить такое разделение.

### Executors и Tasks

**Disclaimer:** интерфейсы Task и Executor в этой задаче не претендуют
  на элегантность и эффективность.

* `Task` - это какой-то кусок вычислений. Сам код вычисления находится в
методе run() и определяется пользователем.
* `Executor` - это набор потоков, которые могут выполнять `Task`-и. 
* `Executor` *должен* запускать потоки в конструкторе, во время работы новых потоков создаваться не должно.
* Чтобы начать выполнять `Task`, пользователь должен отправить его в `Executor` с помощью метода
`Submit()`.
* После этого, пользователь может дождаться пока `Task` завершится, позвав метод `Task::Wait`.

```c++
class MyPrimeSplittingTask : public Task {
    Params params_;
public:
    MyPrimeSplittingTask(Params params) : params_(params) {}
    bool is_prime = false;
    virtual void Run() {
        is_prime = check_is_prime(params_);
    }
}

bool DoComputation(std::shared_ptr<Executor> pool, Params params) {
    auto my_task = std::make_shared<MyPrimeSplittingTask>(params);
    pool->Submit(my_task);
    my_task.Wait();
    return my_task->is_prime;
}
```

* `Task` может завершиться успешно (`IsCompleted`), с ошибкой
  (`IsFailed`) и быть отменён (`IsCanceled`). После того, как с ним
  произошло одно из этих событий - он считается выполненным
  (`IsFinished`).

* Пользователь может в любой момент отменить `Task` с помощью метода
  `Cancel()`. В этом случае, если выполнение `Task`а еще не
  началось, то оно и не должно начаться.

* `Task` может иметь зависимости. Например в задаче reduce сначала
  должны были выполниться reduce-ы по кускам вектора, а потом один
  финальный reduce по промежуточным значениям. Пользователь может
  сказать, что один `Task` должен выполняться только после того как
  выполнился какой-то другой `Task`, позвав метод
  `Task::AddDependency`.

* `Task` может иметь триггеры (`Task::AddTrigger`). В таком случае он должен начать
  выполнение после того как хотя бы один триггер завершился.

* `Task` может иметь один триггер по времени
  (`Task::SetTimeTrigger`). В этом случае он должен начать
  выполнение если наступило время `deadline`.

* В общем случае, `Executor::Submit` не должен начинать выполнение
  сразу, а дожидаться условия:
  * _Или_ есть зависомости и все они выполнились
  * _Или_ один из триггеров выполнился
  * _Или_ выставлен `deadline`, и наступило время `deadline`.
  Если у таска нет зависимостей, нет триггеров и не выставлен deadline,
  то его можно выполнять сразу же.
  Пока `Submit` на таск не вызван, выполнять его нельзя.

* `Executor` предоставляет API для того, чтобы остановить выполнение.
  * `Executor::StartShutdown` - начинает процесс остановки. Таски, которые 
    были посланы после `StartShutdown` должны сразу переходить в состояние Canceled.
    Функция может быть вызвана несколько раз.
  * `Executor::WaitShutdown` - блокируется, пока Executor не остановится.
    Функция может быть вызвана несколько раз.
  * `Executor::~Executor` - неявно делает shutdown и дожидается завершения потоков.

### Futures

Интерфейсы `Task` и `Executor` являются довольно многословными, во второй
части задания вам нужно будет реализовать класс `Future` и несколько комбинаторов к нему.

* `Future` - это `Task`, у которого есть результат (какое-то значение).

* Интерфейсы комбинаторов определены в классе `Executor`:
  * `Invoke(cb)` - выполнить `cb` внутри `Executor`-а, результат вернуть через `Future`.
  * `Then(input, cb)` - выполнить `cb`, после того как закончится `input`. Возвращает `Future` на результат `cb` не дожидаясь выполнения `input`.
  * `WhenAll(vector<FuturePtr<T>> ) -> FuturePtr<vector<T>>` - собирает результат нескольких `Future` в один.
  * `WhenFirst(vector<FuturePtr<T>>) -> FuturePtr<T>` - возвращает результат, который появится первым.
  * `WhenAllBeforeDeadline(vector<FuturePtr<T>>, deadline) -> FuturePtr<vector<T>>` - возвращает все результаты, которые успели появиться до deadline.

### Сдача задания

Чтобы сдать эту задачу, нужно добиться зелёных тестов в CI.

## Советы по реализации

1. Продумайте какие lock-и вам потребуются. Как сделать так, чтобы
    в них не было циклов?
2. Продумайте в каких состояниях может находиться `Task`. Вставьте в
    код `assert`-ы.
3. Начните с базового функционала: `Task`-и `Executor` без
    зависимостей и триггеров. Затем реализуйте зависимости и
    триггеры, поверх этого реализуйте `Future` и комбинаторы.
4. Для реализации таймеров вам потребуется использовать метод
    `wait_until` у `std::condition_variable`.
5. Для эффективной реализации таймеров нужно использовать кучу.
6. Чтобы управлять памятью без утечек вам потребуется использовать `std::weak_ptr` и `std::enable_shared_from_this`.
