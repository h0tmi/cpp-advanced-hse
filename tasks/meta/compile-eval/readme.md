# Вычисления на этапе компиляции

В этой задаче вам предстоит немного погрузиться в удивительный мир вычислений во время компиляции. Будьте аккуратны при компиляции тех или иных решений в этой задаче (например, next prime).
При неаккуратной реализации время компиляции может быть сколь угодно долгим, а потребляемая при этом память сколь угодно большой (вплоть до исчерпания всей вашей ram).

Жаловаться, что здесь нет C++20 запрещено.

Данная задача включает в себя 6 подзадач:

## C++03

В этой секции используется старый стандарт языка C++03. Это означает, что для организации вычислений вы можете использовать только механизм инстанцирования шаблонов (см. ссылки).

### Template pow

Реализуйте шаблон `Pow<int, int>`, приведенный в файле `pow.h`. В `Pow<a, b>::value` должен быть результат выражения $`a^b`$. Считайте, что $`a > 0, b \ge 0`$. 

### Template sqrt

Реализуйте шаблон `Sqrt<n>`, приведенный в файле `sqrt.h`. В `Sqrt<n>::value` должно быть такое наименьшее x, что $`x * x \ge n`$. Воспользуйтесь бинарным поиском для вычисления результата.
Вам также может понадобиться реализовать свой аналог `std::conditional`.

### Полезные ссылки
* https://en.wikipedia.org/wiki/Compile_time_function_execution
* http://en.cppreference.com/w/cpp/types/conditional

## C++11

В этой секции используется стандарт C++11. Это означает, что вам теперь доступны `constexpr` выражения. Однако в этой версии стандарта на constexpr-функции наложены довольно строгие ограничения
(например, функция может представлять собой только выражение вида return ...).

### Pow

Реализуйте функцию `pow(int, int)`, приведенную в `another_pow.h`. Теперь используйте возможности constexpr вместо шаблонов.

### Hash

Реализуйте функцию `hash(const char *s, int p, int m)`, приведенную в `hash.h`. Данная функция должна вычислять следующий полиномиальный хеш строки s на этапе компиляции:
```math
h = \sum\limits_{i = 0}^{|s| - 1} s_i * p^{i} (mod \; m)
```


Подумайте, как переписать эту формулу в рекуррентном виде, а затем реализуйте полученное.

### Полезные ссылки
* http://en.cppreference.com/w/cpp/language/constexpr

## C++14

В этой секции используется стандарт C++14, который существенно ослабил ограничения, налагаемые на constexpr функции, а также ввел широкую поддержку constexpr стандартной библиотекой. Это
позволяет реализовывать намного более сложные алгоритмы на этапе компиляции. Например, теперь можно объявлять переменные внутри функций (и даже создавать объекты, если у них есть constexpr
конструкторы), а также писать циклы и условные выражения.

### Next prime

Реализуйте функцию `next_prime(int)`, приведенную в файле `next_prime.h`. Данная функция по заданному `x` находит такое наименьшее $`y \ge x`$, что y --- простое.

### Determinant

Реализуйте функцию `determinant` в файле `determinant.h`. Данная функция должна вычислять определитель заданной квадратной матрицы. В этой задаче вам могут понадобиться шаблоны с переменным числом аргументов, появившиеся в С++11.

#### Примечание

Так как `T& std::array<T, N>::operator[]` является `constexpr` только [начиная с C++17](https://en.cppreference.com/w/cpp/container/array/operator_at), а мы используем C++14, вам придется присваивать значения через мутабельную ссылку, полученную с помощью `std::get`. Можно использовать такой хелпер:

```cpp
template <int N, int I, int J>
constexpr int& GetElement(std::array<std::array<int, N>, N>& a) {
    return std::get<J>(std::get<I>(a));
}
```

Но так как в нем `I` и `J` передаются как NTTP, то использовать всю силу `constexpr`-функций вы не сможете. Существует способ обойти и эту проблему, для этого нужно вспомнить, как хранится в памяти `std::array`, а также то, как можно работать с указателями на массивы.

###

Заметьте, что в этой задаче нужно собирать тесты подзадач с названиями

* test_templates
* test_constexpr_simple
* test_constexpr

### Полезные ссылки
* http://en.cppreference.com/w/cpp/language/parameter_pack
* http://eli.thegreenplace.net/2014/variadic-templates-in-c/
* https://habrahabr.ru/post/228031/
* http://en.cppreference.com/w/cpp/utility/integer_sequence
