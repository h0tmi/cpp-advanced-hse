# FunctionRef

Реализуйте удобную абстракцию -- легковесную ссылку на функциональный объект (лямбду, функцию, функтор).

Часто необходимо передавать коллбек в функцию, при этом нет возможности тип коллбека сделать шаблонным параметром.
Например, изобразим интерфейс к какому-то хранилищу документов:
```cpp
class Storage {
    void Fetch(
        std::span<DocumentId> docs,
        const std::function<void(size_t, Result<DocumentData>)>& callback
    );
};
```

При вызове Fetch пользователь указывает идентификаторы документов, которые необходимо получить;
реализация Storage скачивает эти документы и, как только очередной документ стал доступен, вызывает пользовательский callback.
При этом, следующий более простой интерфейс менее удобный, так как обрабатывать документы вызывающий код может только после
того, как все документы скачались; если же какой-то документ, например, нашелся в кеше и доступен сразу после вызова Fetch,
в первом варианте мы сразу его можем обработать, не дожидаясь скачивания остальных документов.
```cpp
class Storage {
    std::vector<Result<DocumentData>> Fetch(std::span<DocumentId> docs);
};
```

Однако, `std::function` достаточно дорогой; не хочется создавать временный объект каждый раз на вызов Fetch.
Для решения такой проблемы и существует легковесный function_ref, похожий на `std::span` и `std::string_view`.

### Интерфейс
`FunctionRef` может быть создан из функтора, лямбды или функции:
```cpp
int Return42() {
    return 42;
}

FunctionRef<int()> get_answer = Return42;
int answer = get_answer(); // 42

auto lambda = [] {
    return 19;
};
FunctionRef<int()> get_ka = lambda;
get_ka(); // 19

struct HeavyFunctor {
    char buf[1024 * 1024];

    int operator() const {
        return 0;
    }
};

HeavyFunctor heavy;
FunctionRef<int()> get_heavy_zero{heavy};
get_heavy_zero(); // 0
```

Данный класс не хранит в себе функтор, только ссылается, и использование FunctionRef вне жизни функтора -- ошибка.
```cpp
FunctionRef<int(int a, int b)> adder;
{
    auto lambda = [](int a, int b) {
        return a + b;
    };
    adder = lambda;
}
adder(10, 9); // UB! lambda is dead
```


### Реализация
`FunctionRef` имеет размер, равный двум указателям, ровно как и `string_view`.
Попробуйте хранить два указателя: указатель на какое-то состояние (например, функтор из конструктора) и на
функцию-трамплин такую, что `FunctionRef::operator()` позовет эту функцию, передав туда аргументы и свой стейт.
Функцию-трамплин стоит сконструировать в конструкторе.
