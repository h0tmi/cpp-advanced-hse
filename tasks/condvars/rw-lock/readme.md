# Readers–writer lock

Одной из классических задач параллельного программирования является [задача о читателях-писателях](https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem).
Суть ее в том, что есть некий общий ресурс, и какие-то потоки используют его только в режиме чтения (не внося изменений), а какие-то --- в режиме записи.
При этом одновременно производить чтение могут сразу несколько потоков, а вот писать только один.

RW-lock --- один из примитивов синхронизации, решающий эту задачу. Поскольку многие ресурсы (например, весь STL) поддерживают одновременное чтение (но только уникальную запись),
использование rw-lock вместо мьютекса в таких случаях может улучшить производительность вашей программы. Можно сказать, что в критическую секцию в rw-lock могут войти либо один пишущий поток,
либо несколько читающих.

В файле `rw_lock.h` приведена реализация данного примитива. `read` и `write` принимают функции обратного вызова, которые и выполняют работу по чтению/записи после
прохода в критическую секцию. Обратите внимание на работу с исключениями --- их появление не должно оставлять объект в некорректном состоянии.

В приведенной реализации содержится ошибка. Вы должны реализовать правильную версию RW-lock.

### Вопросы
* В чем именно ошибка в приведенной реализации?
* rw-lock можно реализовать несколькими способами --- отдавать предпочтение пишущим, читающим потокам или же вообще сделать честным (чтобы по аналогии с предыдущей задачей никто не голодал).
Какой стратегии следует ваша реализация?
* Если вы в бенчмарке будете использовать мьютекс вместо rw-lock, то можете получить ускорение. Почему так происходит? Когда все-таки лучше применять простой мьютекс, а не rw-lock?

### Полезные ссылки
* Обратите внимание, что в стандарте С++17 данный примитив добавлен в стандартную библиотеку --- http://en.cppreference.com/w/cpp/thread/shared_mutex (в данной задаче его использование запрещено).
* http://stackoverflow.com/questions/30144875/unlock-a-thread-from-another-thread-in-c11
