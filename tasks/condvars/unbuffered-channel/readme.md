# Unbuffered channel

*Перед выполнением этой задачи стоит решить предыдущую.*

После реализации буферизированного канала вы можете приступить к реализации небуферизированного. Его операции отличаются следующим:
* _send(value)_ --- поток блокируется до тех пор, пока принимающая сторона не получит соответствующее _value_.
* _recv()_ --- поток блокируется до тех пор, пока не появится какой-либо _send_, который можно принять.
* _close()_ --- закрыть канал. Если при этом есть какие-то ожидающие _send_ потоки, то и они, и все последующие попытки _send_ должны завершаться с ошибкой.
А все вызовы _recv_ (как последующие, так и текущие ожидающие) должны возвращать значение, свидетельствующее о том, что канал закрыт.

Как видно из описания, если в буферизированном канале операции send-recv являются асинхронными, то в небуферизированном они синхронны.
Сделавший _send_ (при выходе из него) гарантированно знает, что другой поток уже получил соответствующее `value`. Разумеется, такая синхронизация стоит затрат и небуферизированный канал
обычно менее эффективен. Однако его можно использовать как примитив синхронизации различных потоков. Другим плюсом является тот факт, что если буферизированный канал требует для доставки как
минимум одного копирования (в буфер), то описанный в этой задаче канал может напрямую перемещать значение из одного потока в другой с помощью move-семантики (что в этой задаче не требуется).

Реализуйте описанный канал в файле `unbuffered_channel.h`. Требования к операциям аналогичны предыдущей задаче:
* `send` должен бросать исключение типа `std::runtime_error` при закрытии канала.
* `recv` возвращает `std::optional`, в котором нет значения если канал был закрыт.

Для понимания алгоритма полезно следующее наблюдение: в предыдущей задаче канал имел явное состояние в виде буфера. Вся синхронизация работала с этим состоянием. Однако помимо буфера
в канале было и неявное состояние в виде очереди ожидающих доставки сообщения в буфер (т.е. появляения в нем свободного места). В этой задаче сообщения доставляются напрямую получателю, а значит
описанное неявное состояние тут придется сделать явным и работать уже с ним.

### Ограничения
Время выполнения бенчмарка не должно превышать 4 секунд.
