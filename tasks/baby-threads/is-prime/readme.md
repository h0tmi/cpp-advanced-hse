# Проверка на простоту

В этой задаче предлагается реализовать функцию, проверяющую число на простоту
```cpp
bool is_prime(uint64_t);
```

Ее однопоточный вариант можно найти в `is_prime.cpp` --- это простой поиск делителей до корня числа. Используйте тот же алгоритм, но реализуйте его многопоточную версию. Распределите пространство перебора между потоками и объедините результаты.

Сравните время работы однопоточной и многопоточной версии. Во всех ли случаях многопоточная версия быстрее? Обратите внимание, что если какой-то поток уже нашел делитель числа, то остальным нет никакого смысла продолжать перебор. Подумайте, как реализовать алгоритм так, чтобы другие потоки не совершали холостой работы в таких случаях.

Обратите внимание, что это учебная задача --- на практике для проверки на простоту существуют очень эффективные алгоритмы, например [тест Миллера-Рабина](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test).

CPU-time вашего решения не должно превышать 3000 us. Для определения количества тредов используйте `std::thread::hardware_concurrency();`.

Чтобы собрать бенчмарки, используйте таргет `bench_isprime`, для остальных задач таргеты будут также называться `bench_*`. Чтобы собрать под Thread Sanitizer, используйте ту же инструкцию, как и для ASAN, только замените ASAN на TSAN.

**[Прочитайте](../../../docs/multithreading.md), как мы тестируем задачи на многопоточность.**

### Полезные ссылки
* http://en.cppreference.com/w/cpp/thread/thread
* http://en.cppreference.com/w/cpp/atomic/atomic
