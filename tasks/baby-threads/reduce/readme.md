# Reduce

В этом задании предлагается реализовать левосторонний reduce, т.е. функцию высшего порядка
```math
g(f, initial, a) = f(... f(f(initial, a_1), a_2), a_n)
```

Здесь $`f`$ --- некоторая бинарная коммутативная и ассоциативная функция, а $`a`$ --- массив длины $`n`$.

Однопоточную версию вы можете найти в `reduce.h`. Пользуясь ассоциативностью функции $`f`$, реализуйте многопоточную версию.

* Сравните скорость работы однопоточной и многопоточной версии для простых функций, вроде сложения или умножения. Быстрее ли многопоточная версия, почему?
* Для сохранения результатов каждого потока вы, вероятно, заведете вектор, где в $`i`$-ой ячейке будете хранить результат $`i`$-ого потока. Сравните 2 подхода:
  * писать результат в локальную переменную, а в конце обновить $`i`$-ую ячейку
  * сразу писать результат в $`i`$-ую ячейку в процессе вычисления
* Могут ли эти 2 варианта отличаться по времени работы? Почему?

### Полезные ссылки
* http://en.cppreference.com/w/cpp/thread/thread
* https://en.wikipedia.org/wiki/False_sharing

### Ограничения
Ваша реализация должна работать быстрее однопоточной.
