# Itertools

В этой задаче вам предстоит реализовать несколько вспомогательных функций для работы с последовательностями, подобных тем, что
есть в языке Python.

А именно `Range`, `Zip` и `Group`.
Примеры того, что мы хотим получить в итоге:

```c++
std::vector<int> first{4, 4, 5};
std::list<std::string> second{"aba", "caba"};

for (const auto& elem : Zip(first, second)) {
    // elem.first -> int
    // elem.second -> string
}

for (const auto& elem : Zip(second, Range(second.size()))) {
    // like enumerate
    // elem.first -> string
    // elem.second -> index: 0, 1, 2, ...
}

for (const auto& elem : Group(first)) {
    // elem groups equal elements
    for (const auto& val : elem) {
        // only equal elements here
    }
}
```

Важно то, что все эти функции не создают новых контейнеров, векторов и прочего. Все реализуется посредством итераторов, т.е.
`Range(100500)` не создает вектор из кучи элементов, а возвращает некоторую сущность, по которой можно проитерироваться (как в Python3).

В качестве такой сущности используйте класс `IteratorRange`, определенный в `itertools.h`. Данный класс содержит в себе пару
итераторов (начало и конец последовательности). Основное его назначение --- возвращать из функции как результат, который потом можно
использовать в range-based for (как в примерах выше).

Функция `Range(from, to, step)` должна порождать последовательность `from, from + step, ..., from + k * step`, где `k` --- такое
последнее, что `from + k * step < to`. Реализуйте также сокращенные формы `Range` с 1 и 2 аргументами (см. тесты). Считайте, что
`step` положительный.

Функция `Zip` принимает 2 последовательности (у каждой из которых есть `begin` и `end`) и порождает последовательность соответствующих
пар. При этом функция должна обрезать итоговую последовательность до наименьшей, т.е.

```c++
std::vector<int> a{1, 2, 3};
for (const auto& val : Zip(a, Range(1 << 30))) {
    // 3 итерации
}
```

Функция `Group` возвращает последовательность из `IteratorRange` на идущие подряд подпоследовательности из равных элементов (см. тесты).
Для сравнения используйте только оператор `==`.

Все что мы хотим --- чтобы работал range-based for, поэтому вы можете реализовывать минимальный интерфейс у всех итераторов: конструктор,
префиксный ++, разыменование и оператор !=.

### Примечания

* Чтобы не умереть от количества ошибок компиляции, используйте const везде где только можно. В этой задаче подразумевается read-only
работа с последовательностями.
* В возвращаемом значении функции можно использовать `auto`, чтобы не писать длинный тип руками.
