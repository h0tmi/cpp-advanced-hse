# scheme-tokenizer

Это первая часть scheme. Сначала прочитайте введение к задаче [здесь](../../scheme). Также обязательно сделайте `git pull` перед началом решения.

- [scheme-tokenizer](#scheme-tokenizer)
  - [Что нужно сделать?](#что-нужно-сделать)
  - [Виды токенов](#виды-токенов)
    - [Пример выражения и потока токенов](#пример-выражения-и-потока-токенов)
  - [Интерфейс](#интерфейс)
    - [Базовый тип `Token`](#базовый-тип-token)
    - [Интерфейс токенизатора](#интерфейс-токенизатора)

## Что нужно сделать?

Напишите токенизатор языка Scheme. Токенизатор принимает на вход последовательность символов и возвращает последовательность токенов.

## Виды токенов

- **Число:** `42`, `-4` или `+10`
- **Скобка:** `(` или `)`
- **Quote:** `'`
- **Dot:** `.`
- **Symbol:** Начинается с символов `[a-zA-Z<=>*/#]` и может содержать внутри символы `[a-zA-Z<=>*/#0-9?!-]`. Отдельные
  знаки `+` и `-` мы тоже считаем символами.
- **Boolean** - либо `#t`, либо `#f`. Можно или завести отдельный тип токена под него, или реализовать через `Symbol`.

### Пример выражения и потока токенов

```
'(+ 4 -5)

Quote OpenParen Symbol(+) Const(4) Const(-5) CloseParen
```

## Интерфейс

### Базовый тип `Token`

Мы хотим сделать тип `Token`, который мог бы представить все возможные токены. Желательно, чтобы этот тип не мог находиться в состоянии, которому не соответствует ни один реальный токен.

__Плохой__ пример:

```c++
struct Token {
    bool is_number;
    int number;

    bool is_symbol;
    std::string symbol;

    bool is_left_bracket;
    bool is_right_bracket;
};
```

Что не так в этой структуре?

- Чему будет соответствовать объект, у которого `is_number == true` и `is_operator == true`?
- Что если все поля `is_*` выставлены в `false`?
- Как понять, какие значения может принимать поле `operator`?

Наш токен может быть числом ИЛИ символом ИЛИ скобкой. Для представления такого типа в стандартной библиотеке есть шаблон `std::variant`. Нам нужно сделать 3 типа под каждый из вариантов, а потом подставить типы в параметры шаблона.

__Хороший__ пример:

```c++
#include <variant>

struct SymbolToken {
    std::string name;
};

struct QuoteToken {
};

// Множество скобок ограничено и известно на этапе компиляции.
// Используем enum class.
enum class BracketToken {
    OPEN, CLOSE
};

// Константа - это просто значение. Заводим структуру.
struct ConstantToken {
    int value;
};

struct DotToken {
};

// Чтобы следовать принципу DRY, заводим `using` декларацию.
// Если в будущем добавится новый вариант токена, будет
// достаточно поменять определение в одном месте.
using Token = std::variant<
    ConstantToken,
    BracketToken,
    QuoteToken
>;
```

Как работать с таким типом?

```c++
// Токен неявно создаётся из константы, скобки или символа.
Token a = ConstantToken{5};
Token b = BracketToken::OPEN;
Token c = SymbolToken{"x"};

// Пытаемся достать константу из токена. Если в токене хранится что-то
// другое, вернётся nullptr.
if (ConstantToken* x = std::get_if<ConstantToken>(&a)) {
    std::cerr << "ConstantToken(" << x->Value << ")" << std::endl;
} else {
    std::cerr << "a is not a ConstantToken";
}
```

### Интерфейс токенизатора

Теперь, когда мы смогли сделать тип для токена, нужно определиться с интерфейсом токенизатора. Тут есть разные варианты.

- Читать все токены сразу или по одному.
- Принимать на вход строку или поток `std::istream`.

```c++
// Все сразу из строки.
std::vector<Token> Read(const std::string& string);

// Интерфейс, позволяющий читать токены по одному из потока.
class Tokenizer {
public:
    // Создаёт токенизатор, читающий символы из потока in.
    Tokenizer(std::istream* in);

    // Достигли мы конца потока или нет.
    bool IsEnd();

    // Попытаться прочитать следующий токен.
    // Либо IsEnd() станет true, либо токен можно будет получить через GetToken().
    void Next();

    // Получить текущий токен.
    Token GetToken();
};
```

В этом задании вам нужно реализовать наиболее общий интерфейс.

Как правильно работать с `std::istream`? Можно попробовать читать строки через `operator >>` или `std::getline` и потом итерироваться по ним. Но так мы будем вычитывать из потока больше символов, чем надо. Например:

```c++
std::string Read(std::istream* in) {
    std::string s;
    *in >> s;
    return s;
}

std::stringstream ss;
ss << "4+5";
Read(&ss);
```

Функция `Read` прочитает сразу 3 символа. А нам нужен только один символ, остальные мы будем читать, когда пользователь нас попросит `Next()`.

Гораздо удобнее читать из потока по одному символу через методы `std::istream::peek()` и `std::istream::get()`.

Обратите внимание, что методы читают символ типа `char`, но возвращают `int`. Это сделано для того, чтобы можно было сигнализировать о конце потока - при достижении конца метод вернёт специальное значение `EOF`.

