# scheme-tidy

Это пятая и последняя часть [scheme](../../scheme). Её нужно делать после [scheme-advanced](../advanced).

В этой подзадаче не нужно реализовывать никаких новых функций языка scheme. Все, что требуется - добиться правильной очистки памяти.

## Mark-and-Sweep

Мы напишем сборщик мусора, работающий по алгоритму [Mark-and-Sweep](https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/) - вкратце, он поддерживает граф связей объектов, а при очистке обходит его, начиная с корня, помечает достижимые объекты, затем удаляет непомеченные. Таким образом, компоненты связности, целиком недостижимые из корня, будут удалены - при использовании `std::shared_ptr` такого достичь нельзя.

Как такое написать? Заведем единый класс, который будет содержать всю логику создания и очистки - назовем его `Heap`. `Heap` должен уметь создавать (`Make`) объекты разных типов (но как проверить, что создаются только наследники `Object`?), а также обходить граф объектов и удалять недостижимые. Сделайте интерфейс ваших объектов таким, чтобы их нельзя было создать иначе, как из `Heap::Make`. Еще вам иногда будет нужно клонировать объект - заведите специальный метод `Clone`, который будет уметь правильно клонировать объект с зависимостями, и удалите конструкторы копирования.

Также поддержите логику с зависимостями в `Object` - каждый `Object` должен знать список своих зависимостей, уметь добавлять зависимость и удалять ее. Оформите это как protected-методы `AddDependency` и `RemoveDependency`, не обращайтесь к списку нигде кроме них. Подумайте, что будет зависимостями у числа, у boolean, у пары, у лямбды?

Что будет происходить при обходе графа? Что будет являться корнем, от которого нужно выяснить достижимость? Напишите в `Object` метод `Mark`, который будет помечать зависимости объекта как достижимые, и рекурсивно вызывать `Mark` от них. Метод `Mark` не должен быть доступен публично, он должен вызываться только внутри `Heap` и наследников `Object`.

Воспользуйтесь известным вам паттерном, чтобы не передавать всюду ссылку на `Heap` - ведь создавать объекты может быть нужно в разных частях программы.

## Тестирование

В этой задаче детектор утечек **включен**. Кроме того, в некоторые тесты добавлен подсчет аллокаций и деаллокаций. После завершения всех вычислений, **но до вызова деструктора `Interpreter`** проверяется разница между аллокациями и деаллокациями - она должна быть не слишком большой: в частности, она может быть положительной, только если при вычислениях создавались или изменялись глобальные переменные. После вызовов функций и лямбд не должно оставаться новых объектов в памяти, так как они не меняют окружение. Таким образом мы проверяем, что сборка мусора вызывается не в конце жизни интерпретатора, а после каждого `Run` (подумайте, чем плохой первый подход).

Тесты на функциональность аналогичны `scheme-advanced`.

Вы можете реализовать сборку мусора по-своему, главное, чтобы она была корректной, то есть не допускала утечек, и вызывалась после каждого вычисления. Мы оставляем за собой право просмотреть решения этого пункта вручную и отклонить те, которые не удовлетворяют данным свойствам.
