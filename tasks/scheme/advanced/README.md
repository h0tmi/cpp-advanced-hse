# scheme-advanced

Это четвертая часть [scheme](../../scheme). Её нужно делать после [scheme-basic](../basic).

- [scheme-advanced](#scheme-advanced)
  - [Что нужно сделать?](#что-нужно-сделать)
    - [If](#if)
    - [Переменные](#переменные)
    - [Лямбда-функции](#лямбда-функции)
    - [Захват контекста](#захват-контекста)
      - [Lambda capture in C++](#lambda-capture-in-c)
  - [Работа с памятью](#работа-с-памятью)
  - [Тестирование](#тестирование)

## Что нужно сделать?

Осталось добавить в наш интерпретатор поддержку `if`, переменных и лямбда-функций с захватом контекста.

### If

Работает как if :D Возможны 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`

Сначала вычисляет `condition` и проверяет значение на истинность (см. определение истинности). Затем вычисляет либо `true-branch`, либо `false-branch` и возвращает как результат всего `if`-а.

### Переменные

Поддержка переменных реализована с помощью особых форм `define` и `set!`.

```scheme
$ (define x 1)
> ()
$ x
> 1
```

Обратите внимание на возвращаемое значение `define`. Команда `set!` используется для изменения значения **существующей**
переменной:

```scheme
$ (define x 1)
> ()
$ (set! x 2)
$ x
> 2
$ (set! y 1)
> NameError
```

Еще есть особые формы `set-car!` и `set-cdr!`. C их семантикой предлагается разобраться самостоятельно, изучив [тесты](./test_pair_mut.cpp), особенно обратите внимание на тесты `SelfReferenceCar` и `SelfReferenceCdr` - разберитесь с помощью `mit-scheme`, как устроены рекурсивные структуры в Scheme.

### Лямбда-функции

Синтаксис:

* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda (x) (set! x (* x 2)) (+ 1 x))`
* `(lambda () 1)`

Создаёт новую функцию. Сначала перечисляется список аргументов функции, затем её тело. Тело может состоять из нескольких выражений, в этом случае они вычисляются по порядку а результат последнего выражения становится результатом функции.

Запись `(define (fn-name <args>) <body>)` эквивалентна `(define fn-name (lambda (<args>) <body>))`. То есть, запись `(define (inc x) (+ x 1))` создаёт новую функцию `inc`.

### Захват контекста

#### Lambda capture in C++

Также возможен и захват контекста. Синтаксис примерно совпадает с C++:

```c++
auto Range(int x) {
  return [&x] () {
    ++x;
    return x;
  };
}

void F() {
  auto r = Range(10);

  std::cout << r() << std::endl; // 11
  std::cout << r() << std::endl; // 12
}
```

В **Scheme**:

```scheme
$ (define range
    (lambda (x)
      (lambda ()
        (set! x (+ x 1))
        x)))

$ (define my-range (range 10))

$ (my-range)
> 11

$ (my-range)
> 12
```

Заметьте, что такой код на С++ содержит UB - ссылка на `x` становится висящей после выхода из `Range()`. В Scheme такого не происходит - объект должен жить, пока на него кто-либо ссылается.

Вложенных scope может быть сколь угодно много. Больше примеров использования лямбда-функций вы найдете в тестах.

## Работа с памятью

В отличие от предыдущих подзадач, в этой возможен сценарий, когда два объекта ссылаются друг на друга ("циклические ссылки"). Как вы знаете, `std::shared_ptr` в таком случае не обеспечивает корректного удаления. Чтобы не делать эту подзадачу слишком сложной, в ней мы отключили на сервере детектор утечек, а вопросы правильной очистки памяти мы обсудим отдельно в [последней части](../tidy).

## Тестирование

Устроено аналогично scheme-basic. Таргет для REPL называется `scheme_advanced_repl`. Естественно, в этой подзадаче запускаются и тесты на весь предыдущий функционал.

Отключить детектор утечек локально можно, если запускать вашу программу с переменной окружения `ASAN_OPTIONS=detect_leaks=0`. Из командной строки запуск будет выглядеть так:
```bash
ASAN_OPTIONS=detect_leaks=0 ./test_scheme_advanced
```
В CLion нужно поменять значение `detect_leaks` на 0 в параметрах address-санитайзера (раздел `Build, Execution, Deployment -> Dynamic Analysis Tools -> Sanitizers` настроек).

Также можно тестировать ваше решение на MacOS, используя дефолтный компилятор Apple Clang - так утечки тоже не будут ловиться.
