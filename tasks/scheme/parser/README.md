# scheme-parser

Это вторая часть [scheme](../../scheme). Её нужно делать после подзадачи [tokenizer](../tokenizer).

- [scheme-parser](#scheme-parser)
  - [Что нужно сделать?](#что-нужно-сделать)
  - [Синтаксис scheme](#синтаксис-scheme)
  - [Рекурсивный спуск](#рекурсивный-спуск)
  - [Обработка ошибок](#обработка-ошибок)
  - [Тестирование](#тестирование)

## Что нужно сделать?

Теперь вам нужно написать парсер для языка scheme. Парсер должен принимать последовательность токенов и строить по ним *синтаксическое дерево* - некоторое внутреннее представление заданного выражения, структуру данных, которая будет передана вычисляющему алгоритму. Код токенизатора нужно переиспользовать из предыдущей задачи, используя `#include <tokenizer.h>`.

Синтаксическое дерево должно состоять из наследников класса `Object`.

## Синтаксис scheme

* В простом случае выражения языка состоят из одного числа, boolean-а или идентификатора. В этом случае дерево разбора состоит из одной вершины - числа или идентификатора. Для представления числа нужно сделать отдельный класс, наследник `Object`. Для представления идентификатора тоже нужно сделать отдельный класс.

```
5
+
foo-bar
```

* Выражение может быть парой. Пара обозначается круглыми скобками с точкой между двумя элементами. Для пары тоже нужно завести отдельный класс. Например, для выражения `(1 . 2)` должно строиться дерево из 3-х элементов. Корнем дерева является пара с двумя потомками.

* Выражение может быть списком. Список - это одна из двух сущностей:

    1. Пустой список. Обозначается пустыми скобочками - `()`. Можно думать, что это объект-константа со специальной
       семантикой.
    2. Пара, в которой второй элемент это список. В этом случае первый элемент пары называется головой (head) списка, а
       второй - хвостом (tail).

Из этого определения следует, что список из трех элементов можно записать так:

```
(1 . (2 . (3 . ())))

 pair => pair => pair => ()
  |       |       |
  1       2       3
```

Однако так записывать списки неудобно и разработчики языка добавили сокращенную запись:

```
(1 2 3)
```

Так записывается "правильный" список (proper list). Заметьте, что парсер должен по обоим представлениям списка строить **одинаковое** синтаксическое дерево.

В языке также есть поддержка "неправильных" списков (improper list). В таком списке второй элемент самой вложенной пары не является пустым списком.

```
(1 . (2 . 3))
pair => pair => 3
  |       |
  1       2
```

Для таких списков тоже есть сокращенная запись:

```
(1  2 . 3)
```

Элементы списков могут любыми корректными выражениями:

```
((1 . 2) (3 4) 5)
(1 () (2 3 4) 5)
```

* Пустой список нужно представлять с помощью `nullptr`.

## Рекурсивный спуск

Грамматика языка `scheme` лежит в классе `LL(1)`. Это значит, что можно написать рекурсивный алгоритм разбора, который заглядывает всего на один токен вперёд.

В авторском решении удалось обойтись всего двумя взаимно рекурсивными функциями: `Read` и `ReadList`.

- `Read` читает произвольное значение.
- `ReadList` читает список, пару или список с точкой в конце.

`Read` заглядывает на 1 токен вперёд.

1. Если стоит число или имя, то выражение состоит из одного элемента.
2. Если же там стоит `(`, то нужно вызвать рекурсивно `ReadList`.

`ReadList` в цикле вызывает `Read`, пока не встретит `)`.

Поддержку `QuoteToken` в этой подзадаче делать необязательно, мы займемся этим дальше. Можете выкидывать `SyntaxError`, если такой токен все-таки попался.

## Обработка ошибок

Ваш парсер должен проверять входной поток на корректность. В случае, если поток токенов не соответствует корректному выражению, нужно бросать исключение `SyntaxError`, определенное в `error.h`.

В этой подзадаче мы проверяем ваш парсер в том числе с помощью fuzzing-теста. Это вид тестирования, при котором на вход программе подаются случайные последовательности токенов, и проверяется, что алгоритм корректно их обрабатывает. В нашем случае корректная обработка - это либо возвращение синтаксического дерева, либо выбрасывание `SyntaxError`.

Если ваш парсер упал на fuzzing-тесте, добавьте директиву `#define SCHEME_FUZZING_1_PRINT_REQUESTS` в parser.h (именно в header!), перезапустите тест и посмотрите на последнюю строку, которая вывелась перед падением. На сервере также можно выводить запросы - с помощью той же директивы.

## Тестирование

При тестировании этой подзадачи запускаются также и тесты на токенайзер.
