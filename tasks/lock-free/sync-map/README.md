# sync-map

**Эту задачу нужно решать после `hazard-ptr`**.

В это задаче вам нужно реализовать хеш-таблицу, оптимизированную
под нагрузку с редкими обновлениями и частыми лукапами.

Если вам нужна read-only хеш таблица, которую будут читать много потоков,
то лучше всего взять `std::unordered_map` или аналоги. Любая многопоточная хеш таблица будет
медленнее, потому что будет содержать дополнительные накладные расходы на синхронизацию.

Но не всегда получается обойтись read-only хеш таблицей. Иногда в таблицу нужно добавлять
записи, по ходу работы. В ситуации когда обновления часты, можно защитить таблицу обычным `std::mutex`.
Если обновления редкие, можно использовать `std::shared_mutex` вместо `std::mutex`,
чтобы многие чтения могли выполняться одновременно. Но `std::shared_mutex` будет работать
медленнее, чем `std::unordered_map` совсем без синхронизации, потому что операции `read_lock()` и
`read_unlock()` требуют синхронизации внутри. В самой наивной реализации вам нужно поддерживать
атомарный счётчик ридеров, и увеличивать/уменьшать его на единицу. А работа с одной атомарной
переменной приводит к contention, как вы уже видели в других задачах.

Оказывается, с помощью hazard_ptr можно реализовать хеш таблицу, которая будет работать
быстрее чем shared_mutex, в ситуации когда обновления редки.

Мы будем держать две хеш таблицы:

- Первая таблица никогда не будет меняться, и читать её мы будем используя hazard_ptr.
- Вторая таблица будет изменяться под мьютексом.

Сначала изменения будут попадать во вторую таблицу. Пока вторая таблица не пуста,
все операции будут захватывать мьютекс. После того как достаточно операций чтения
выполняться с захватом мьютекса, мы перенесём все элементы из второй таблицы в первую.

После этого потоки будут читать read-only таблицу без мьютекса.

Если после этого опять выполнить insert, новая запись попадёт во вторую таблицу и все операции
на какое-то время снова будут выполняться со взятием мьютекса.

Если обновления редкие, то вторая таблица почти всегда будет пуста,
и все чтения будут успешно выполняться без лока.

```c++
struct Snapshot {
    std::shared_ptr<std::unordered_map<K, V>> read_only;

    // Indicates that read_only snapshot may be incomplete and lookup should take lock.
    bool dirty = false;
};

std::atomic<Snapshot*> snapshot_;

std::mutex lock_;
std::shared_ptr<std::unordered_map<K, V>> mutable_map_;
int operation_count_ = 0;
```
