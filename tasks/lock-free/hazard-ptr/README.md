# hazard-ptr

Hazard Pointer - это схема управления памятью, применяемая в lock free алгоритмах.

Мы будем рассматривать упрощённый алгоритм Hazard Pointer с одним указателем, схема обобщается
на произвольное число указателей.

Для того, чтобы понять мотивацию, сначала посмотрим на модельный пример задачи, которая решается c помощью
hazard ptr.

Класс `State` задаёт некоторое состояние. Множество потоков читают это состояние. Другие потоки хотят обновлять состояние
целиком, подменяя указатель `State*` на новое значение.

Этe задачу можно решить с помощью rwlock.

```c++
class State;

State* value = nullptr;
std::shared_mutex lock;

void Read() {
    std::shared_lock guard(lock);
    DoRead(value);
}

void Update(State* new_value) {
    State* old_value;

    {
        std::unique_lock guard(lock);
        old_value = value;
        value = new_value;
    }

    delete old_value;
}
```

Читающие потоки работают с указателем, держа `shared_lock`. Обновляющий поток берёт `unique_lock` и подменяет указатель.

У этого решения есть несколько проблем:

- Пишущий поток блокирует читателей.
- Читающие потоки создают contention на shared_mutex.

Такое решение подходит, если указатель на `State` читается и обновляется достаточно редко. Но в случае с lock_free структурами данных,
такое действие с указателем требуется на каждую операцию.

Попробуем реализовать то же самое, через atomic переменные.

```c++
class State;

std::atomic<State*> value = nullptr;

void Read() {
    auto snapshot = value.load();
    DoRead(snapshot);
}

void Update(State* new_value) {
    State* old_value = value.exchange(new_value);
    delete old_value;
}
```

Очевидная проблема этого решения: old_value будет удалён, до того как все читающие потоки закончили работу с этим
объектом. Чтобы избавиться от этой проблемы, нам потребуются hazard_ptr. Мы будем действовать так.

1. Каждый читающий поток заведёт переменную `std::atomic<State*> hazard_ptr`. При работе с указателем, поток будет сохранять этот
указатель в свой `hazard_ptr`. После того, как поток закончил работать с указателем, он будет очищать свой `hazard_ptr`.

2. Удаляющий поток будет освобождать память только после того как убедится, что никакой читающий поток больше не работает с этим
указателем.

Мы спрячем реализацию Hazard Ptr за интерфейс с тремя операциями: `Acquire`, `Release` и `Retire`. Кроме этого, нам
потребуется еще 2 технических функции: `RegisterThread` и `UnregisterThread`.

```c++
// Acquire атомарно читает значение *ptr и добавляет это значение
// в множество защищённых указателей.
//
// Один поток в один момент времени может держать только один указатель в множестве защищённых.
//
// Объект, на который ссылается std::atomic<T*> должен быть удалён с использованием Retire. Нельзя удалять
// этот объект напрямую через delete.
template <class T>
T* Acquire(std::atomic<T*>* ptr);

// Release удаляет текущий активный указатель из множества защищённых.
void Release();

// Retire отправляет объект в очередь на удаление.
//
// Объект будет удалён в произвольный момент времени в будущем. Гарантируется, что удаление не произойдёт,
// пока объект находится в множестве защищённых.
//
// Пользователь должен гарантировать, никакой другой поток уже не имеет доступа к
// *value через атомарные переменные.
template <class T>
void Retire(T* value);

// Каждый поток обязан позвать RegisterThread перед работой с Hazard Ptr. 
void RegisterThread();

// UnregisterThread вызывается каждым потоком перед завершением. Работать с Hazard Ptr после вызова UnregisterThread нельзя.
void UnregisterThread();
```

Реальные реализации Hazard Ptr не имеют ограничений на число защищённых указателей и прячут от пользователя вызовы
`RegisterThread` и `UnregisterThread`.

Решение модельной задачи с использованием Hazard Ptr будет выглядеть так:

```c++
class State;

std::atomic<State*> value = nullptr;

void Read() {
    auto snapshot = Acquire(&value);
    DoRead(snapshot); // Можно работать с snapshot, объект защищён от удаления.
    Release();
}

void Update(State* new_value) {
    State* old_value = value.exchange(new_value);
    if (old_value) {
        // exchange гарантирует, то никакой другой поток уже не увидит old_value.
        // можно звать Retire.
        Retire(old_value);
    }
}
```

Можете убедиться, что гарантий `Acquire`, `Release` и `Retire` достаточно, чтобы доказать корректность этого решения.

## Реализация

Эта секция опишет основные идеи и структуры данных. Полностью реализовать Hazard Ptr вам нужно будет самим.

Для хранения множества защищённых указателей, мы будем использовать такую структуру данных:

```c++
thread_local std::atomic<void*> hazard_ptr{nullptr};

class ThreadState {
    std::atomic<void*>* ptr;
};

std::mutex threads_lock;
std::unordered_set<ThreadState*> threads;
```

Все зарегистрированные потоки хранятся в одном сете. Добавление и удаление происходит под локом.
Каждый поток хранит свой защищённый указатель в thread_local переменной. Указатель на эту переменную
доступен из ThreadState. Другие потоки могут читать множество защищённых указателей, взяв `threads_lock` и
пробежавщить по `threads`.

Реализация `Acquire` и `Release` выглядит так:

```c++
template <class T>
T* Acquire(std::atomic<T>* ptr) {
    auto value = ptr->load(); // (2)

    do {
        hazard_ptr.store(value);

        auto new_value = ptr->load(); // (3)
        if (new_value == value) { // (1)
            return value;
        }

        value = new_value;
    } while (true);
}

void Release()
{
    hazard_ptr.store(nullptr);
}
```

Мы читаем атомарный указатель, сохраняем его значение в `hazard_ptr` и проверяем что значение указателя не изменилось.
Если условие (1) выполнилось, гарантируется что указатель ссылается на тот же самый объект, что мы прочитали в строчке (2).

Численные значения указателей равны, так что ссылаться на другой объект мы можем только в случае, если произошла ABA проблема,
и объект успели освободить, а на его месте создать новый. Но функция `Acquire` требует, чтобы объект удаляли через `Retire`.
А пользователь функции `Retire` гарантирует, что другие потоки не могут прочитать указатель на объект из атомарных переменных,
до того как `Retire` был вызван. Значит либо `Retire` был вызван одновременно, и тогда условие (1) будет ложным. Либо между
(2) и (3) на объект не вызывали `Retire` и тогда функция `Acquire` атомарно прочитала указатель и добавила его в множество защищённых.

Реализация `Retire` должна работать так:

```c++
struct RetiredPtr {
    void* value;
    std::function<void()> deleter;
    RetiredPtr* next;
};

std::atomic<RetiredPtr*> free_list = nullptr;
std::atomic<int> approximate_free_list_size = 0;

void Retire(T* ptr) {
    // 1) Add ptr to free list.
    ...
    // 2) Increment free list size.
    ...
    // 3) Scan free list, if size > K.
    ScanFreeList();
}
```

Мы добавляем указатель в очередь на удаление. Когда размер очереди становится слишком большим, мы запускаем
дорогую операцию сканирования очереди. Очередь удаления является lock-free стеком, который мы разбирали
в задаче mpsc-stack.

Сканирование `free_list` состоит из нескольких шагов:

```c++
std::mutex scan_lock;

void ScanFreeList() {
    // (0) Обнуляем approximate_free_list_size, чтобы другие потоки не пытались зайти в ScanFreeList вместе с нами.

    // (1) С помощью мьютекса убеждаемся, что не больше одного потока занимается сканированием.
    // В реальном коде не забудьте использовать guard.
    if (!scan_lock.try_lock()) {
        return
    }

    // (2) Забираем все указатели из free_list
    RetiredPtr* retired = free_list.exchange(nullptr);

    // (3) Читаем множество защищённых указателей обойдя все ThreadState.
    std::vector<void*> hazard;
    {
        std::unique_lock guard(threads_lock);
        for (const auto& thread : threads) {
            if (auto ptr = thread.ptr->load(); ptr) {
                hazard.push_back(ptr);
            }
        }
    }

    // (4) Сканируем все retired указатели.
    //    (a) Для тех, что не находятся в hazard, вызываем деструктор и освобождаем память под RetiredPtr.
    //    (b) Те, что еще находятся в hazard, кладём назад в free_list.
    //
    // Для ускорения, hazard нужно посортировать и использовать бинарный поиск.
}
```

`ScanFreeList` никогда не удалит указатель, который находится в множестве защищённых. Сначала мы читаем `free_list`,
а затем `hazard`. Порядок важен. Если указатель уже находится в `free_list`, он не может быть добавлен в `hazard`.
Значит нашей проверки в (4) достаточно, чтобы обеспечить гарантии по удалению.

## Критерии

Все бенчмарки должны занимать < 30ns по real time.
