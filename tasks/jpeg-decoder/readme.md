# JPEG Decoder

<img src="tests/bad_quality.jpg" alt="harold" width="600"/>

В этом домашнем задании вам предстоит реализовать декодер JPEG. Подробности будут рассказаны на семинарах.

- [JPEG Decoder](#jpeg-decoder)
  - [Установка библиотек](#установка-библиотек)
    - [Ubuntu](#ubuntu)
    - [OS X](#os-x)
  - [Оценивание](#оценивание)
  - [Что надо сделать](#что-надо-сделать)
    - [Huffman](#huffman)
    - [FFTW](#fftw)
    - [Baseline](#baseline)
    - [Faster](#faster)
    - [Progressive](#progressive)
    - [Fuzz](#fuzz)
      - [Запуск `fuzz_decoder_baseline` c корпусом](#запуск-fuzz_decoder_baseline-c-корпусом)
  - [Материалы](#материалы)
  - [Инфраструктура](#инфраструктура)
  - [Как не страдать при отладке](#как-не-страдать-при-отладке)

## Установка библиотек

### Ubuntu

```sh
sudo apt install libjpeg-dev libpng-dev libfftw3-dev
```

### OS X

```sh
brew install libjpeg libpng fftw
```

На MacOS могут возникать проблемы с определением этих библиотек CMake. Инструкции для такого случая есть в [CMakeLists.txt](./CMakeLists.txt).

## Оценивание

Задача разделена на 6 подзадач.

| Название                    | Стоимость | Таргет для тестов          | Таргет для фаззинга     |
| --------------------------- | --------- | -------------------------- | ----------------------- |
| [huffman](#huffman)         | 2 балла   | `test_decoder_huffman`     | `fuzz_decoder_huffman`  |
| [fftw](#fftw)               | 1.5 балла | `test_decoder_fftw`        | `fuzz_decoder_fftw`     |
| [baseline](#baseline)       | 2.5 балла | `test_decoder_baseline`    | `fuzz_decoder_baseline` |
| [faster](#faster)           | 1.5 балл  | `test_decoder_faster`      | `fuzz_decoder_faster`   |
| [progressive](#progressive) | 2.5 балла | `test_decoder_progressive` |                         |
| [fuzz](#jpeg-fuzz)          | см. ниже  |                            |                         |

* Fuzzing-тестирование на сервере будет запущено после дедлайна для всех решений. В случае, если сданы подзадачи *huffman* и *fftw*, прохождение этих тестов прибавляет **1 балл**. Если также сданы подзадачи *baseline* и *faster*, то прибавляются **еще 1.5 балла**. Таким образом, вы можете получить **10 баллов** без подзадачи *progressive*. 

## Что надо сделать

### Huffman

> Суть: реализовать декодирование с помощью дерева Хаффмана

Смотрите секцию [The actual DHT in the JPEG file](https://www.impulseadventure.com/photo/jpeg-huffman-coding.html) и слайды.

На вход классу подается вектор `code_lengths`, где `code_lengths[i]` - количество листьев на глубине `i + 1` (если `root` имеет глубину 0). Также на вход подаются значения, записанные в листьях этого дерева в порядке обхода "сначала левое поддерево, потом правое".

Также имплементируйте метод `Move`, реализующий интерфейс движения по ребру с заданным значением `bit` дерева из текущей вершины. Если конечная вершина ребра является листом, значение в листе нужно записать в переданную переменную и вернуть `true`. Текущая вершина в дереве при этом сбрасывается, и при следующем вызове метода начальной вершиной будет не лист дерева.

Обратите внимание, что header-файл `huffman.h` уже написан и находится в каталоге `include/`. Не меняйте его, он не отправится на сервер - используйте pimpl.

### FFTW

> Cуть: реализовать IDCT (обратное дискретное косинусное преобразование) при помощи FFTW

На вход подаются двумерные матрицы 8x8 в одномерном виде (чтобы было быстрее).

Поищите в [документации](https://www.fftw.org/index.html) по ключевым словам IDCT/DCT:
* какие функции вам надо использовать
* с какими параметрами (спойлер: там должно быть что-то про двумерность)

Переиспользуйте план между вызовами при реализации следующего пункта. Не забудьте удалить план, когда он больше не нужен. Для удаления есть специальная функция в библиотеке.

### Baseline

> Суть: ~~нарисуйте сову~~ используйте предыдущие две подзадачи, чтобы реализовать декодер, умеющий читать файлы.

Храните информацию о том, сколько байт вы просканировали, чтобы понимать текущую позицию в файле и общий прогресс по JPEG.

### Faster

> Суть: ускорить свою реализацию, чтобы в релизе она успевала обработать большой jpeg за меньше, чем 8 секунд

Используйте `perf record` и `perf report` для вашего бинаря в релизной сборке (замените `ASAN`/`TSAN` -> `RelWithDebInfo`). Запустите `perf top` или постройте флеймграф вашей программы (если вы не знаете, что это значит - смотрите последнюю лекцию).

Еще идеи для оптимизаций:

* Деление на одно и то же число можно заменить на умножение на обратное
* Делать `reserve` перед `push_back`
* Оптимизация дерева Хаффмана
* Исправить хранение матриц
* Прописать явно в коде таблицу переходов при раскрутке зиг-зага

В целом, любые хаки в рамках разумного разрешены (никакой глобальной памяти, пожалуйста).

### Progressive

> Суть: продвинутая версия JPEG декодера, которая позволит читать любые жпеги мира.

Не обсуждается на семинарах. Здесь вам придется разобраться со [спецификацией JPEG](http://www.w3.org/Graphics/JPEG/itu-t81.pdf).

### Fuzz

> Суть: проверить, что ваше решение не содержит известных багов с помощью fuzzing-тестирования.

Обратите внимание, для локальной отладки вам потребуется Clang (Apple Clang не подойдет). На Ubuntu его можно установить с помощью [скрипта](https://apt.llvm.org/), на OS X выполните `brew install llvm`.

Чтобы собрать таргеты не дефолтным компилятором, создайте отдельную сборочную директорию и передайте `cmake` аргументы `-DCMAKE_C_COMPILER=PATH_TO_YOUR_CLANG -DCMAKE_CXX_COMPILER=PATH_TO_YOUR_CLANG++`.

На Ubuntu, как правило, достаточно в качестве пути указать `clang-XX` / `clang++-XX`, где XX - версия. На OS X путь, куда установился LLVM, узнайте через `brew --prefix llvm`, к нему обычно нужно добавить `llvm/bin/clang` / `llvm/bin/clang++` соответственно. Проверьте, что компилятор в выводе `cmake` тот, который вы ожидаете.

В случае проблем локально приходите на учебный сервер.

#### Запуск `fuzz_decoder_baseline` c корпусом

Чтобы фаззинг с большей вероятностью нашел баги в вашем коде, будем запускать его с корпусом. В качестве стартового корпуса будем использовать изображения из [tests](./tests). Скопируйте куда-нибудь эту директорию и передайте путь к копии в аргументах командной строки:

```bash
./fuzz_decoder_baseline path_to_copied_tests_directory
```

Копировать нужно, так как фаззер может добавлять новые входы в корпус и записывать их в переданный каталог.

После запуска последите за процессом первые несколько минут. Когда фаззер перестанет находить ошибки быстро, оставьте его поработать на несколько часов, например, на ночь.

Если ваше решение упало на каком-то входе, можно запустить на нем еще раз (например, с дебаггером) - передайте путь к файлу в аргументе командной строки вместо каталога.

При тестировании на сервере будет действовать следующее правило: если нашелся вход, на котором упало хотя бы одно решение, этот вход добавляется в корпус и на нем проверяются все остальные решения. Таким образом, локальное тестирование не может полностью гарантировать, что вы пройдете тестирование на сервере, однако длительные прогоны фаззера повышают вероятность этого.

## Материалы

* [Wikipedia](https://en.wikipedia.org/wiki/JPEG), русскую версию читать не стоит.
* [Пошаговый разбор с Хабра](https://habrahabr.ru/post/102521/).
* [JPEG-snoop](https://github.com/ImpulseAdventure/JPEGsnoop), утилита для дебага,
  без проблем запускается под wine (Ubuntu) или CrossOver (OS X), показывает подробную информацию 
  про JPEG файл
* [Спецификация JPEG](http://www.w3.org/Graphics/JPEG/itu-t81.pdf), понадобится для progressive части.
* [Дополнительный пост для любознательных](https://habrahabr.ru/post/206264/).
* [Презентация](JPEG_Decoder.pdf)

## Инфраструктура

- В этом задании вы можете добавлять свои файлы с исходниками. Напомним, что если вы добавляете `.cpp`, нужно указать его в списке исходников библиотеки в `sources.cmake` подзадачи.

- Изменять можно только файлы в каталогах подзадач. Header-файлы в include/ менять нельзя, они уже написаны. Вспомните идиому pimpl, она используется в `HuffmanTree` и `DctCalculator`.

- Для вашего удобства мы подключили библиотеку для логирования `glog`, ниже вы найдете краткий туториал по ней, больше -- в официальной документации.

- В тестах есть возможность записать на диск результаты работы вашего декодера в формате `png`. Чтобы ее включить, пропишите в CMakeLists.txt строку

```cmake
target_compile_definitions(test_decoder_baseline PUBLIC HSE_ARTIFACTS_DIR="YOUR_PATH")
```

где `YOUR_PATH` --- путь к директории, в которую будут записаны артефакты. Директория должна существовать. Можно либо указать абсолютный путь (не используйте символ `~`, `fopen` не умеет его интерпретировать), либо указать относительный, тогда он будет вычисляться относительно директории, в которой вы запускаете `test_decoder_baseline`.

**Присылайте интересные артефакты в чат курса :)**

## Как не страдать при отладке

В проект подключена библиотека логирования и валидации [glog](http://rpg.ifi.uzh.ch/docs/glog.html).
Используйте ее вместо стандартного потока вывода. Что из этой библиотеки может пригодиться вам:

- Разный уровень логирования:

```cpp
DLOG(INFO) << "Preparing coffee";
DLOG(ERROR) << "Oh, our ship is about to blow up!";
```

- Логирование сообщения только при выполнении какого-то предиката:

```cpp
DLOG_IF(INFO, errors > 10) << "Well, we should stop now, I guess";
```

- Логирование не каждого события, а каждых N событий:

```cpp
DLOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th error";
```

- Валидация инвариантов:

```cpp
CHECK(write(x) == 4) << "Write failed!";
CHECK_NE(1, 2) << ": The world must be ending!";
CHECK_EQ(std::string("abc")[1], 'b');
```

