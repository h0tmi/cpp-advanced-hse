# List

В этой задаче вам нужно реализовать шаблонный контейнер на основе
двусвязного списка. Интерфейс находится в файле `list.h`.

## Реализация двусвязного списка

В реализации списка вам придётся проводить очень много манипуляции с
указателями. В подобном коде довольно просто ошибиться, поэтому стоит
потратить усилия и вынести код меняющий указатели в отдельные функции.

Код получится проще всего, если реализовать 2 примитива:
  * `void Unlink(ListNode* node)` - _вывязывает_ элемент из списка.
  * `void LinkAfter(ListNode* target, ListNode* after)` - _провязывает_
    элемент `after` в список после элемента `target`.
  
Также можно упростить код, если сделать список циклическим. В
циклическом списке поле `next` последнего элемента ссылается на первый
элемент. В таком списке указатели `next` и `prev` никогда не могут
быть равны `nullptr`, а значит в коде не нужно будет писать проверок
на `nullptr` и значит нельзя будет ошибиться и забыть про эту
проверку.

Если вы последуете этому совету, то рано или поздно у вас возникнет
вопрос: _Как представлять пустой список?_. Проще всего завести
фиктивый элемент, чтобы список никогда небыл пустым.

Но и тут есть одна хитрость. Элемент списка - это примерно такой класс:

```c++
class ListNode {
private:
  T value_;
  ListNode* next_;
  ListNode* prev_;
};
```

Вы не можете создать фиктивный элемент, потому что `T` - это какой-то
пользовательский тип. И никто не гарантирует, что у этого типа есть
конструктор по умолчанию.

У этой проблемы есть элегантное решение с использованием ООП.
Попробуйте придумать его сами.

## Отладка

Скорее всего, у вас возникнут проблемы с указателями. Есть несколько трюков, которые помогут в отладке.
  1. Можно печатать на `cout` численное значение указателя и искать поломки глазами.
  2. Можно написать функцию `void CheckRep(ListNode* )`, которая проходится по
     списку и проверяет все инварианты `assert`-ами. Такую функцию можно звать 
     после каждой модификации списка или из кода тестов.
  3. Вы можете попробовать переопределить `operator new` и `operator delete`,
     чтобы они печатали лог работы с кучей. [Смотрите первый пример кода](http://en.cppreference.com/w/cpp/memory/new/operator_new)

## Интерфейс итератора

В этой задаче вам нужно будет реализовать свой итератор. Для этого
придётся переопределять операторы. Помните:

 * `++x` заменяется на вызов `operator++()`
 * `x++` заменяется на вызов `operator++(int)`, где параметр фиктивный.
 * `--x` и `x--` работают аналогично `++`.
 * `*x` заменяется на вызов `operator*()`
 * `x->field` заменяется на `(x->operator->())->field`.
