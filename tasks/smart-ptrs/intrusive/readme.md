# IntrusivePtr

Общая информация по задачам на умные указатели [здесь](../readme.md).

### Что это?
`IntrusivePtr` -- умный указатель, похожий по семантике на `SharedPtr`, без возможности брать `WeakPtr` на указатель.
При этом, как вы увидите, реализация данного класса намного проще, чем `SharedPtr`.
Это достигается за счет ограничения на пользовательский тип. Он должен удовлетворять следующему условию:
1. Внутри типа находится счетчик ссылок (поэтому указатель интрузивный: счетчик находится прямо в объекте).
1. Есть метод `IncRef()`, уменьшающий внутренний счетчик ссылок
1. Есть метод `DecRef()`, уменьшающий внутренний счетчик ссылок; при достижении нуля объект автоматически разрушается.
1. Есть метод `RefCount()`, возвращающий текущее значения счетчика.

Важно, что все состояние указателя находится в объекте, на который он указывает. Это позволяет создавать корректный `IntrusivePtr` из сырого указателя, ровно как с `enable_shared_from_this`.

Рядом с `IntrusivePtr` реализован удобный класс-миксин, позволяющий вставить счетчик ссылок в любой объект, просто отнаследовавшись от него:
```cpp
class MyClazzWithIntrusiveCounter : public SimpleRefCounted<MyStringWithIntrusiveCounter> {
    ...
};
```

### Зачем это?
За счет более строгих требований на пользовательский тип, чем у `SharedPtr`, и отсутствия `WeakPtr` `IntrusivePtr` реализуется намного проще и эффективнее.
Удобная абстракция со внешним счетчиком ссылок позволяет легко использовать `IntrusivePtr` для нетривиальных времен жизни (см. `ObjectPool` в тестах).
Большую часть использований `std::shared_ptr` в вашем коде на самом деле можно заменить на более легковесный `IntrusivePtr`.
