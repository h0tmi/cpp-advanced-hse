# Immutable vector

В предыдущих задачах мы уже реализовывали много разных стандартных структур, такие как вектор, список и т.д.. В этой задаче мы
познакомимся с другим классом структур, которые обычно используются в функциональных языках, таких как Haskell, Scala и других.

А именно, там широко используются _иммутабельные_ (неизменяемые) структуры данных. В такой структуре
любая "изменяющая" операция не модифицирует исходную структуру, а возвращает новую с примененными изменениями. Например, рассмотрим обычный массив `a`.
Операция `a.set(5, 3)` присвоит 5-ому элементу массива значение 3, тем самым изменив его. В иммутабельном массиве операция `a.set(5, 3)` возвращает новый
массив, в котором в 5-ом элементе записано значение 3, а остальные элементы такие же, как и в `a`, который остался без изменений.

Иммутабельность обычно подразумевает и _персистентность_ структуры данных, т.е. эффективную работу с различными версиями структуры. Действительно, поскольку все операции с иммутабельной структурой
возвращают ее новые версии, структура должна эффективно работать с этими версиями, иначе применение иммутабельности будет дорого обходиться. Разумеется, любую структуру можно сделать
иммутабельной, просто делая полную копию текущей структуры в каждой операции. Однако помимо того, что это неэффективно, хранение многих версий такой структуры вряд ли возможно.

При эффективной реализации иммутабельность имеет следующие плюсы:
1. Такую структуру легче использовать в многопоточном коде (в следующем семестре это станет ясно).
2. Все операции с такой структурой дают сильную гарантию на исключения, что естественно, т.к. нет модифицирующих структуру операций.
О различных гарантиях можно почитать [здесь](https://en.wikipedia.org/wiki/Exception_safety).
3. Иммутабельность дает и версионируемость, а значит можно эффективно откатывать структуру в более ранние состояния, делать снимок текущего состояния.

В этой задаче вам предстоит реализовать упрощенный аналог контейнера `scala.collection.immutable.Vector` --- иммутабельного динамического массива из языка Scala. Реализация должна быть в файле
`immutable_vector.h`, где сейчас находится интерфейс.

### Полезные ссылки и подсказки
* Почитать про реализацию в scala: [раз](http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#vectors),
[два](http://www.scala-lang.org/api/2.12.0/scala/collection/immutable/Vector.html)
* Используйте такой же алгоритм как в scala --- реализуйте персистентный бор, где пути образованы битами индексов. Поскольку использовать 1 бит числа неэффективно (глубина дерева порядка 32), то
берите биты группами. Реализация в scala использует коэффициент ветвления 32, т.е. 5 бит числа, таким образом, глубина дерева будет составлять максимум 4-5.
* Операция `set(index, value)` в неперсистентном боре производит спуск в дереве по битам `index` до нужного узла, а затем его модификацию. Для реализации персистентности используйте метод копирования
пути, описанный в предыдущих источниках.
* Каждая модифицирующая операция таким образом будет создавать новый корень. Тогда конкретная версия структуры характеризуется корнем.
* Чтобы аккуратно работать с памятью, отлично подходит `std::shared_ptr`, который автоматически будет отслеживать все ссылки на узлы и удалять ненужные части структуры по мере необходимости.
* Вы можете считать, что если в операциях `index` больше текущего размера, то результат не определен. `push_back` должен использовать индекс, равный количеству элементов в векторе.
* Берите биты от младших к старшим (как в scala) --- не нужно делать бор фиксированной высоты, создавая лишние узлы для нулевых старших битов.
